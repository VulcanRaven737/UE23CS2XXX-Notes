# OOAD with Java â€” Unit II: Complete Study Notebook

**Compiled & Taught by Your Personal AI Tutor** **Based on: _Java the Complete Reference_, Herbert Schildt & _Applying UML and Patterns_, Craig Larman**

---

> **How to use this notebook:** Each major topic is explained in full depth with examples, analogies, and code. After every big topic, there is a ðŸ§  **Test Yourself** section with Q&A. Work through the questions _before_ reading the answers!

---

# Table of Contents

1. [Introduction to Java & Its Features](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#1-introduction-to-java--its-features)
2. [JVM, JDK, and How Java Runs](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#2-jvm-jdk-and-how-java-runs)
3. [Two Programming Paradigms: Process-Oriented vs OOP](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#3-two-programming-paradigms)
4. [The Three OOP Principles](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#4-the-three-oop-principles)
5. [Composition](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#5-composition)
6. [Classes and Objects in Java](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#6-classes-and-objects-in-java)
7. [Access Modifiers](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#7-access-modifiers)
8. [Packages](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#8-packages)
9. [Primitive and Object Data Types](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#9-primitive-and-object-data-types)
10. [Operators in Java](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#10-operators-in-java)
11. [Unique Java Features (Enums, Enhanced For, Labeled Loops)](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#11-unique-java-features)
12. [Strings in Java](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#12-strings-in-java)
13. [Constructors (All Types)](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#13-constructors-all-types)
14. [Garbage Collection & Finalization](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#14-garbage-collection--finalization)
15. [Passing Parameters in Java](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#15-passing-parameters-in-java)
16. [Polymorphism (Compile-time & Runtime)](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#16-polymorphism)
17. [Recursion](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#17-recursion)
18. [Instance Variables vs Class Variables](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#18-instance-variables-vs-class-variables)
19. [The `this` Keyword](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#19-the-this-keyword)
20. [Exception Handling](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#20-exception-handling)
21. [Inheritance (All Types)](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#21-inheritance-all-types)
22. [Method Overloading & Overriding](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#22-method-overloading--overriding)
23. [Abstract Classes](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#23-abstract-classes)
24. [Interfaces](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#24-interfaces)
25. [Abstract Class vs Interface](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#25-abstract-class-vs-interface)
26. [Nested Classes](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#26-nested-classes)
27. [Arrays & the Arrays Utility Class](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#27-arrays--the-arrays-utility-class)
28. [Java Collections Framework (JCF)](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#28-java-collections-framework-jcf)
29. [The Java Object Class](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#29-the-java-object-class)
30. [Architectural Patterns (MVC, Layered, Microservices, Event-Driven)](https://claude.ai/chat/e33e4212-61a7-474c-bfaa-beb9959033d8#30-architectural-patterns)

---

---

# 1. Introduction to Java & Its Features

## What is Java?

Java is a **general-purpose, class-based, object-oriented programming language** designed to have as few implementation dependencies as possible. Its famous motto is:

> **"Write Once, Run Anywhere" (WORA)**

This means that compiled Java code can run on any platform that has a Java Virtual Machine (JVM) â€” you write the code once and it runs on Windows, Mac, Linux, etc.

---

## Features of Java â€” Explained in Detail

### 1. Simple

Java was designed to be easy to learn. Its syntax is clean and closely mirrors C/C++, but removes confusing features like pointers and operator overloading.

### 2. Object-Oriented

Everything in Java is an object (except primitive types). Java enforces the OOP principles of encapsulation, inheritance, and polymorphism.

### 3. Platform Independent

Java source code is compiled into **bytecode** (not machine code). This bytecode is then interpreted by the JVM on any platform. Two layers:

- **JVM** â€” platform specific (each OS has its own JVM)
- **Bytecode** â€” platform independent (runs on any JVM)

### 4. Secured

- No explicit pointers (prevents direct memory access attacks)
- Java programs run inside a **sandbox** (the JVM), isolating them from the OS

### 5. Robust

Java is reliable because:

- **Strong memory management** â€” memory is managed by the JVM
- **No pointers** â€” eliminates dangling pointer bugs
- **Automatic Garbage Collection** â€” automatically frees unused memory
- **Exception handling** â€” structured error management
- **Type checking** â€” errors are caught at compile time

### 6. Architecture-Neutral

The size of primitive types is fixed regardless of the machine. For example, `int` is always 32 bits â€” unlike in C/C++ where it can vary.

### 7. Portable

Java bytecode can be carried and run on any platform without needing any recompilation.

### 8. High-Performance

Java bytecode is "close to native code," making it faster than traditional interpreted languages. While slower than fully compiled languages (C/C++), it uses **Just-In-Time (JIT) compilation** at runtime to improve performance.

### 9. Distributed

Java supports distributed applications through **RMI (Remote Method Invocation)** and **EJB (Enterprise JavaBeans)**, enabling programs to call methods on remote machines over a network.

### 10. Multi-Threaded

Java supports **multithreading** natively â€” multiple threads of execution can run concurrently within a single program. Threads share common memory, making them lightweight and efficient.

### 11. Dynamic

Java supports **dynamic class loading** â€” classes are loaded on demand when they are first needed, not all at startup. It also supports dynamic compilation and automatic garbage collection.

---

## ðŸ§  Test Yourself â€” Features of Java

**Q1.** Why is Java called "platform independent" even though the JVM is platform dependent?

> **Answer:** Java source code is compiled into **bytecode**, which is not specific to any OS or hardware. This bytecode is platform-independent. The JVM then interprets this bytecode and translates it to native machine code for the specific platform it runs on. So the _bytecode_ travels freely, while the _JVM_ handles the platform-specific details.

**Q2.** What makes Java "robust"? Name at least 3 features.

> **Answer:** Strong memory management, no explicit pointers, automatic garbage collection, exception handling, and type-checking mechanism.

**Q3.** What is the difference between portability and platform independence?

> **Answer:** _Platform independence_ means the source/bytecode can conceptually run anywhere. _Portability_ refers to the practical ability to carry the bytecode to any platform and actually execute it without requiring any changes.

**Q4.** Why is Java considered multi-threaded, and why does it matter for multimedia apps?

> **Answer:** Java allows defining multiple threads â€” independent sub-programs running concurrently. Threads share memory (unlike processes), so they're efficient. Multimedia apps benefit because they can handle audio, video, user input, and network communication simultaneously.

---

---

# 2. JVM, JDK, and How Java Runs

## The JVM (Java Virtual Machine)

The JVM is an **abstract machine** (a software-based virtual computer). It provides the runtime environment in which Java bytecode executes.

**The JVM does four things:**

1. **Loads code** â€” reads the `.class` bytecode file
2. **Verifies code** â€” checks that bytecode is safe and correct
3. **Executes code** â€” runs the bytecode (instruction by instruction, or via JIT compilation)
4. **Provides runtime environment** â€” memory management, garbage collection, etc.

> âš ï¸ The JVM itself is **platform dependent** â€” there's a different JVM for Windows, Linux, Mac. But the bytecode it runs is **platform independent**.

## How a Java Program Runs â€” Step by Step

```
Your Java Code (.java file)
         â†“
   Java Compiler (javac)
         â†“
   Bytecode (.class file)
         â†“
   JVM interprets bytecode
         â†“
   Native machine code runs on your OS
```

**Commands:**

```bash
javac HelloWorld.java    # Compiles â†’ produces HelloWorld.class
java HelloWorld          # Runs the bytecode using the JVM
```

## The JDK (Java Development Kit)

The JDK is the complete software development environment for Java. It includes:

- The Java compiler (`javac`)
- The JVM (`java`)
- Standard libraries
- Debugging tools

---

## ðŸ§  Test Yourself â€” JVM & Running Java

**Q1.** If the JVM is platform dependent, how can we say Java is "Write Once, Run Anywhere"?

> **Answer:** The JVM is platform-dependent, but it acts as a translation layer. The bytecode (the `.class` file) is the thing you "write once." Each OS has its own JVM that understands how to run that _same_ bytecode. So from the developer's perspective, they write code once and it runs anywhere a JVM is installed.

**Q2.** What is the difference between `javac` and `java`?

> **Answer:** `javac` is the **compiler** â€” it converts `.java` source code into `.class` bytecode. `java` is the **JVM launcher** â€” it reads the `.class` bytecode and executes it.

**Q3.** What file does `javac HelloWorld.java` produce?

> **Answer:** `HelloWorld.class` â€” a bytecode file.

---

---

# 3. Two Programming Paradigms

## The Problem: How do we organize programs?

All programs have two things: **code** and **data**. How you organize the relationship between them defines your programming paradigm.

## Paradigm 1: Process-Oriented (Procedural)

- Program = a series of linear steps (code acting on data)
- The _process_ (what is happening) is the organizing principle
- Languages: C, Pascal, FORTRAN
- Works fine for small programs; becomes unmanageable as complexity grows

**Analogy:** Think of a factory assembly line â€” each station performs a specific step in a fixed sequence. Good for repetitive tasks, but hard to adapt.

## Paradigm 2: Object-Oriented Programming (OOP)

- Program = a collection of objects (data controlling access to code)
- The _data_ (who is being affected) is the organizing principle
- Objects are self-contained â€” they hold data AND the operations on that data

**Analogy:** Think of a car. You don't know how the engine, transmission, or braking system works internally. But you know the interface â€” steering wheel, accelerator, brakes. This abstraction lets you use the car without being overwhelmed by its 10,000 parts.

## Why OOP over Procedural?

|Feature|Procedural|OOP|
|---|---|---|
|Organization|Around code/functions|Around data/objects|
|Reusability|Limited|High (via inheritance)|
|Scalability|Difficult|Easier|
|Abstraction|Manual|Built-in|
|Maintainability|Hard at scale|Better|

---

---

# 4. The Three OOP Principles

Java is built on three core OOP principles. Think of them as a holy trinity â€” each enables and amplifies the others.

---

## 4.1 Encapsulation

### What is it?

Encapsulation is the **bundling of data (variables) and the methods that operate on that data into a single unit (a class)**, while restricting direct access to the internals from the outside.

Think of a **capsule (a tablet)**: the medicine inside is protected by the outer shell. You consume the capsule through a defined interface â€” you don't directly pour the powder yourself.

### How it works in Java:

- **Class** = the protective wrapper
- **Private fields** = protected data (no direct outside access)
- **Public methods** = the controlled interface (getters/setters)

```java
public class BankAccount {
    private double balance;  // Encapsulated â€” hidden from outside

    public void deposit(double amount) {
        if (amount > 0) balance += amount;  // Controlled access
    }

    public double getBalance() {
        return balance;  // Controlled read
    }
}
```

### Why does encapsulation matter?

1. **Safety** â€” Prevents accidental or malicious modification of data
2. **Flexibility** â€” You can change the internal implementation without affecting code that uses the class
3. **Maintainability** â€” Bugs are isolated inside the class

---

## 4.2 Inheritance

### What is it?

Inheritance is the process by which **one class (child/subclass) acquires the properties and behaviors of another class (parent/superclass)**.

It represents an **IS-A** relationship.

```
Animal (superclass)
  â””â”€â”€ Dog (subclass) â€” a Dog IS-A Animal
       â””â”€â”€ GoldenRetriever (subclass of Dog)
```

```java
class Animal {
    String name;
    void eat() { System.out.println("eating..."); }
}

class Dog extends Animal {   // Dog inherits from Animal
    void bark() { System.out.println("woof!"); }
}

// Dog now has: name, eat(), AND bark()
```

### Why does inheritance matter?

- **Code reuse** â€” don't rewrite what you've already written
- **Hierarchical modeling** â€” models the real world naturally
- **Foundation for polymorphism** â€” enables method overriding

---

## 4.3 Polymorphism

### What is it?

Polymorphism (Greek: "many forms") allows **one interface to be used for a general class of actions**. The specific action is determined by the exact context at runtime or compile time.

The key phrase: **"One interface, multiple methods"**

```java
// Same method name, different behavior
class Calculator {
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }  // overloaded
}
```

Think of a power outlet â€” it's the same interface (2/3 pin), but you plug in a phone charger, a laptop, a fan â€” all different behaviors from the same interface.

---

## How They Work Together

- **Encapsulation** provides the building blocks (self-contained classes)
- **Inheritance** establishes hierarchies and enables code reuse
- **Polymorphism** allows those hierarchies to be used flexibly and generically

A well-designed class hierarchy enables **code reuse** (inheritance), **safe evolution** (encapsulation), and **clean generic code** (polymorphism).

---

## ðŸ§  Test Yourself â€” OOP Principles

**Q1.** What does the term "encapsulation" literally mean in the context of Java?

> **Answer:** Binding data (member variables) and code (methods) together into a single unit (class), and controlling access to the internals through a well-defined interface (public methods), keeping the data safe from outside interference.

**Q2.** What keyword is used in Java to implement inheritance?

> **Answer:** `extends`. Example: `class Dog extends Animal`

**Q3.** "One interface, multiple methods" describes which OOP principle?

> **Answer:** **Polymorphism**.

**Q4.** What is the difference between "IS-A" and "HAS-A" relationships?

> **Answer:** IS-A is inheritance (a Dog IS-A Animal). HAS-A is composition (a Car HAS-A Engine). They represent different design choices.

**Q5.** Can you have encapsulation without inheritance? What about the reverse?

> **Answer:** Yes â€” each pillar can exist independently. You can fully encapsulate a class without it ever being inherited. And you can have inheritance without private members. However, good OOP design uses all three together.

---

---

# 5. Composition

## What is Composition?

Composition is a design technique that implements the **HAS-A relationship**. Instead of inheriting behavior, a class achieves it by **containing an instance of another class**.

```java
class Engine {
    void start() { System.out.println("Engine starting..."); }
}

class Car {
    private Engine engine;  // Car HAS-A Engine

    Car() {
        this.engine = new Engine();
    }

    void startCar() {
        engine.start();     // Delegates to the Engine
    }
}
```

## Composition vs Inheritance

||Inheritance (IS-A)|Composition (HAS-A)|
|---|---|---|
|Relationship|"Is a type of"|"Has a part"|
|Coupling|Tight|Loose|
|Flexibility|Less flexible|More flexible|
|Example|Dog IS-A Animal|Car HAS-A Engine|

### Key Rule â€” Composition's "Full Dependency":

In composition, the **contained object cannot exist without its container**. If you destroy the `Car`, the `Engine` inside it is also meaningless/destroyed. This is stronger than simple aggregation (where parts can exist independently).

---

## ðŸ§  Test Yourself â€” Composition

**Q1.** Which relationship does composition implement: IS-A or HAS-A?

> **Answer:** **HAS-A**.

**Q2.** In a `House` that HAS-A `Room`, if the `House` is destroyed, what happens to the `Room`?

> **Answer:** In true composition, the `Room` ceases to exist meaningfully â€” it's fully dependent on the `House`. This is the defining characteristic of composition.

**Q3.** Why might you prefer composition over inheritance?

> **Answer:** Composition is more flexible and loosely coupled. You can swap out components (e.g., replace the engine) without changing the entire class hierarchy. It avoids the "fragile base class" problem of inheritance.

---

---

# 6. Classes and Objects in Java

## Class â€” The Blueprint

A **class** is a user-defined data type that acts as a template/blueprint for creating objects. It defines:

- **Attributes** (member variables) â€” the data
- **Behaviors** (member methods) â€” the operations

```java
// A class definition
public class Bicycle {
    // Member variables (attributes)
    String color;
    int speed;
    int gear;

    // Member method (behavior)
    void accelerate(int increment) {
        speed += increment;
    }
}
```

## Object â€” An Instance

An **object** is a concrete instance of a class. It has physical reality â€” actual memory is allocated. You can create many objects from the same class.

```java
// Creating objects (instances) of the Bicycle class
Bicycle myBike = new Bicycle();
Bicycle yourBike = new Bicycle();

myBike.color = "Red";
yourBike.color = "Blue";
```

## Class Declaration â€” Full Structure

```java
[access_modifier] class ClassName [extends SuperClass] [implements Interface1, Interface2] {
    // member variables
    // constructor(s)
    // methods
}
```

- **Class name** â€” must start with a capital letter (convention)
- **extends** â€” for inheriting from a superclass (only ONE allowed)
- **implements** â€” for implementing interfaces (MANY allowed)

## First Java Program

```java
// File must be named: HelloWorld.java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

### Breaking down `System.out.println("Hello World")`:

1. `System` â€” a class in `java.lang` providing standard I/O mechanisms
2. `out` â€” a `PrintStream` object (static field of `System`)
3. `println` â€” a method of `PrintStream` that prints text + newline
4. `"Hello World"` â€” the `String` argument passed to println

## Command Line Arguments

```java
public class Greet {
    public static void main(String[] args) {
        System.out.println("Hello, " + args[0]);   // args[0] = first argument
        System.out.println("Total args: " + args.length);
    }
}
// Run: java Greet Alice   â†’ prints "Hello, Alice"
```

---

## ðŸ§  Test Yourself â€” Classes & Objects

**Q1.** What is the difference between a class and an object?

> **Answer:** A class is a **blueprint** â€” a logical construct, no memory used. An object is an **instance** of a class â€” it has physical reality with actual memory allocated. One class can produce unlimited objects.

**Q2.** The filename in Java must match what?

> **Answer:** The filename must match the **public class name**. If the class is `public class HelloWorld`, the file must be `HelloWorld.java`.

**Q3.** What does `args.length` return in a main method?

> **Answer:** The number of command-line arguments passed to the program.

**Q4.** Can a class extend multiple superclasses in Java?

> **Answer:** **No.** Java only supports single inheritance for classes. A class can extend only ONE superclass. (But it can implement multiple interfaces.)

---

---

# 7. Access Modifiers

Access modifiers control the **visibility and accessibility** of class members (fields and methods).

|Modifier|Within Class|Within Package|Outside Package (Subclass)|Outside Package|
|---|---|---|---|---|
|`private`|âœ…|âŒ|âŒ|âŒ|
|`default` (no keyword)|âœ…|âœ…|âŒ|âŒ|
|`protected`|âœ…|âœ…|âœ…|âŒ|
|`public`|âœ…|âœ…|âœ…|âœ…|

```java
class Example {
    private int x;       // Only inside this class
    int y;               // Default: only within the package
    protected int z;     // Package + subclasses outside package
    public int w;        // Everywhere
}
```

---

## ðŸ§  Test Yourself â€” Access Modifiers

**Q1.** Which access modifier is the most restrictive?

> **Answer:** `private` â€” accessible only within the declaring class.

**Q2.** What is the default access level when no modifier is specified?

> **Answer:** **Package-level access** (also called "default"). The member is accessible within the same package only.

**Q3.** A subclass is in a different package. Which modifiers allow it to access inherited members?

> **Answer:** `public` and `protected`. Private and default members cannot be accessed.

---

---

# 8. Packages

## What is a Package?

A package is a **namespace that organizes related classes and interfaces** â€” like a folder in a file system. Two main reasons:

1. **Avoid name conflicts** â€” two classes can have the same name if they're in different packages
2. **Better code organization** â€” related classes are grouped together

## Types of Packages

**Built-in Packages** â€” part of the Java API:

- `java.lang` â€” core classes (String, Math, System) â€” **automatically imported**
- `java.util` â€” utilities (ArrayList, Scanner)
- `java.io` â€” input/output

**User-defined Packages** â€” you create them:

```java
package com.myapp.models;   // declares which package this class belongs to

public class User { ... }
```

## Importing Packages

```java
import java.util.Scanner;    // import a single class
import java.util.*;          // import the entire package
```

## Using Scanner (Input)

```java
import java.util.Scanner;

public class InputExample {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();        // reads an integer
        String s = sc.nextLine();    // reads a full line
        double d = sc.nextDouble();  // reads a double
    }
}
```

---

---

# 9. Primitive and Object Data Types

## Primitive Data Types

These are the most basic building blocks. They hold values directly (stored on the **stack**).

|Type|Size|Range / Description|
|---|---|---|
|`boolean`|1 bit|`true` or `false`|
|`byte`|8 bits|-128 to 127|
|`short`|16 bits|-32,768 to 32,767|
|`char`|16 bits|Unicode character|
|`int`|32 bits|~-2.1 billion to 2.1 billion|
|`long`|64 bits|Very large integers|
|`float`|32 bits|Floating point (~7 decimal digits)|
|`double`|64 bits|High precision floating point (~15 digits)|

## Wrapper Classes (Object Types)

Every primitive has a corresponding **wrapper class** (a full object). These are stored on the **heap** and have methods.

|Primitive|Wrapper|
|---|---|
|`boolean`|`Boolean`|
|`byte`|`Byte`|
|`short`|`Short`|
|`char`|`Character`|
|`int`|`Integer`|
|`long`|`Long`|
|`float`|`Float`|
|`double`|`Double`|
|_(no primitive)_|`String`|

### Autoboxing / Unboxing

Java automatically converts between primitives and wrappers:

```java
int x = 5;
Integer obj = x;       // autoboxing: int â†’ Integer
int y = obj;           // unboxing: Integer â†’ int
```

---

## ðŸ§  Test Yourself â€” Data Types

**Q1.** What is the size (in bits) of an `int` in Java?

> **Answer:** **32 bits** (4 bytes). This is fixed regardless of the OS â€” one of Java's architecture-neutral features.

**Q2.** Why would you use `Integer` instead of `int`?

> **Answer:** `Integer` is a full object â€” it can be stored in collections (like `ArrayList`, which only stores objects). It also has useful methods like `Integer.parseInt()`. `int` is faster but can't be used where objects are needed.

**Q3.** What is `String` in Java â€” primitive or object?

> **Answer:** **Object** (a reference type). But unlike most objects, String literals can be created without `new`: `String s = "hello";`

---

---

# 10. Operators in Java

## Complete Operator Reference

### Assignment

|Operator|Meaning|
|---|---|
|`=`|Simple assignment|

### Arithmetic

|Operator|Meaning|
|---|---|
|`+`|Addition (also String concatenation)|
|`-`|Subtraction|
|`*`|Multiplication|
|`/`|Division|
|`%`|Modulus (remainder)|

### Unary

|Operator|Meaning|
|---|---|
|`+`|Unary plus (positive)|
|`-`|Unary minus (negate)|
|`++`|Increment by 1|
|`--`|Decrement by 1|
|`!`|Logical NOT (flips boolean)|

### Relational

|Operator|Meaning|
|---|---|
|`==`|Equal to|
|`!=`|Not equal to|
|`>`|Greater than|
|`>=`|Greater than or equal|
|`<`|Less than|
|`<=`|Less than or equal|

### Conditional (Logical)

|Operator|Meaning|
|---|---|
|`&&`|AND (short-circuit)|
|`\|`|OR (short-circuit)|
|`?:`|Ternary: `condition ? valueIfTrue : valueIfFalse`|

### Type Comparison

|Operator|Meaning|
|---|---|
|`instanceof`|Tests if an object is an instance of a type|

### Bitwise & Bit Shift

|Operator|Meaning|
|---|---|
|`~`|Bitwise complement|
|`<<`|Signed left shift|
|`>>`|Signed right shift|
|`>>>`|Unsigned right shift|
|`&`|Bitwise AND|
|`^`|Bitwise XOR|
|`\|`|Bitwise OR|

### Ternary Example:

```java
int max = (a > b) ? a : b;   // if a > b, max = a, else max = b
```

---

---

# 11. Unique Java Features

## 11.1 Enums

An **enum** (enumeration) is a special type used to define a collection of **named constants**. Use it when you have a fixed set of values that won't change.

```java
public enum Day {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY;
}
```

### Enum Methods:

|Method|Description|
|---|---|
|`values()`|Returns array of all enum constants|
|`valueOf("SUNDAY")`|Returns the constant with that name|
|`name()`|Returns the name of the constant as a String|
|`ordinal()`|Returns the position (0-indexed)|

```java
Day d = Day.WEDNESDAY;
System.out.println(d.name());     // "WEDNESDAY"
System.out.println(d.ordinal());  // 3
```

### Enums vs Classes:

- Enum constants are implicitly `public`, `static`, and `final`
- Enums cannot create objects using `new`
- Enums cannot extend other classes (but CAN implement interfaces)
- Enums CAN have fields and methods

**When to use Enums:** When values are known at compile time and won't change â€” months, days, colors, suits in a deck of cards, planet names, etc.

---

## 11.2 Enhanced For Loop (For-Each)

```java
int[] numbers = {1, 2, 3, 4, 5};

// Traditional for loop
for (int i = 0; i < numbers.length; i++) {
    System.out.println(numbers[i]);
}

// Enhanced for loop (for-each) â€” cleaner!
for (int num : numbers) {
    System.out.println(num);
}
```

---

## 11.3 Labeled Continue Statements

From JDK 1.5, you can label loops and `continue` or `break` an outer loop specifically:

```java
outer:
for (int i = 0; i < 3; i++) {
    for (int j = 0; j < 3; j++) {
        if (j == 1) continue outer;  // skips to next iteration of outer loop
        System.out.println(i + ", " + j);
    }
}
```

---

## 11.4 Switch on Strings (Java 7+)

```java
String day = "MONDAY";
switch (day) {
    case "MONDAY": System.out.println("Start of work week"); break;
    case "FRIDAY": System.out.println("End of work week"); break;
    default: System.out.println("Midweek");
}
```

---

---

# 12. Strings in Java

## Creating Strings

```java
String s1 = "Hello World";                    // String literal (preferred)
String s2 = new String("Hello World");        // Using constructor
```

## Immutability â€” The Most Important String Property

**Strings in Java are immutable.** Once created, their value cannot be changed. When you "modify" a string, a new String object is created.

```java
String s = "Hello";
s = s + " World";     // Does NOT modify s â€” creates a NEW String "Hello World"
                      // The old "Hello" becomes eligible for garbage collection
```

### Why are Strings immutable? Three big reasons:

1. **String Pool / Memory efficiency** â€” Java stores String literals in a pool. Multiple variables can share the same object, reducing memory.
2. **Thread Safety** â€” Immutable objects are naturally thread-safe; no synchronization needed.
3. **Reliable Hashing** â€” Consistent hash code makes Strings reliable as keys in `HashMap`.

## Key String Methods

|Method|Description|Example|
|---|---|---|
|`length()`|Number of characters|`"hello".length()` â†’ 5|
|`charAt(i)`|Character at index i|`"hello".charAt(1)` â†’ 'e'|
|`indexOf("l")`|First index of substring|`"hello".indexOf("l")` â†’ 2|
|`substring(2, 4)`|Extract substring|`"hello".substring(2, 4)` â†’ "ll"|
|`toUpperCase()`|Convert to uppercase|`"hello".toUpperCase()` â†’ "HELLO"|
|`toLowerCase()`|Convert to lowercase|`"HELLO".toLowerCase()` â†’ "hello"|
|`trim()`|Remove leading/trailing spaces|`" hi ".trim()` â†’ "hi"|
|`replace('l', 'r')`|Replace characters|`"hello".replace('l', 'r')` â†’ "herro"|
|`contains("ell")`|Check if contains|`"hello".contains("ell")` â†’ true|
|`equals("hello")`|Case-sensitive comparison|`"hello".equals("Hello")` â†’ false|
|`equalsIgnoreCase()`|Case-insensitive comparison|â†’ true|
|`split(" ")`|Split into array|`"a b c".split(" ")` â†’ ["a","b","c"]|
|`concat(str)`|Concatenate|Appends str|
|`startsWith("he")`|Check prefix|â†’ true|
|`endsWith("lo")`|Check suffix|â†’ true|

## String to Number Conversions

```java
int i = Integer.parseInt("42");
double d = Double.parseDouble("3.14");
long l = Long.parseLong("9876543210");
float f = Float.parseFloat("1.5");
```

---

## ðŸ§  Test Yourself â€” Strings

**Q1.** What does it mean for Strings to be "immutable"?

> **Answer:** Once a String object is created, its content cannot be modified. Operations that appear to modify a String (like `+` or `replace()`) actually create a **new** String object; the original is untouched.

**Q2.** What is the String Pool?

> **Answer:** A special area in the JVM heap where String literals are stored. If two variables have the same string literal value, they point to the _same_ object in the pool instead of creating two separate objects. This saves memory.

**Q3.** What is the output of: `"Hello".length() + "World".length()`?

> **Answer:** `10` â€” "Hello" has 5 chars, "World" has 5 chars. `5 + 5 = 10`.

**Q4.** Will `"hello" == "hello"` always return `true`?

> **Answer:** For String literals from the pool, yes (same reference). But for objects created with `new String("hello")`, it may return `false` because they are different objects in memory. Always use `.equals()` to compare String **content**.

---

---

# 13. Constructors (All Types)

## What is a Constructor?

A constructor is a **special method** that:

- Has the **same name as the class**
- Has **no return type** (not even `void`)
- Is **called automatically** when you create an object with `new`
- Its purpose: **initialize the newly created object**

```java
class Bike {
    String model;
    int price;

    // Constructor
    Bike(String m, int p) {
        model = m;
        price = p;
    }
}

// When this runs, the constructor is automatically called:
Bike b = new Bike("Yamaha", 150000);
```

**Is a constructor mandatory?** No. If you don't write one, Java automatically provides a **default constructor** (no-args, does nothing). But once you define any constructor, the default is no longer provided automatically.

---

## Types of Constructors

### 1. No-Argument (Default) Constructor

```java
class Car {
    String color = "White";

    Car() {   // No-argument constructor
        System.out.println("Car created with default color: " + color);
    }
}
Car c = new Car();   // Calls the no-arg constructor
```

> **Note:** "Default constructor" technically refers to the one the **compiler adds** automatically. A no-argument constructor you write yourself is called a **no-argument constructor**, not a default constructor â€” but many people use the terms interchangeably.

---

### 2. Parameterized Constructor

```java
class Student {
    String name;
    int age;

    Student(String n, int a) {   // Parameterized
        name = n;
        age = a;
    }
}

Student s = new Student("Alice", 20);
```

> **Parameter** = the variable in the constructor's definition (`String n`) **Argument** = the actual value you pass when calling (`"Alice"`)

---

### 3. Copy Constructor

A copy constructor creates a **new object as a copy** of an existing object. Java doesn't provide one by default (unlike C++) â€” you must write it yourself.

```java
class Bike {
    String model;
    int price;

    Bike(String m, int p) {
        model = m;
        price = p;
    }

    // Copy constructor â€” takes an object of the same class
    Bike(Bike other) {
        this.model = other.model;
        this.price = other.price;
    }
}

Bike original = new Bike("Yamaha", 150000);
Bike copy = new Bike(original);     // Uses copy constructor
```

### Copy Constructor vs `clone()`

||Copy Constructor|`clone()` method|
|---|---|---|
|Type|Deep copy|Shallow copy|
|Control|You control it|Limited control|
|Safety|Safer|Can be tricky|

**Deep copy** = copies all fields, including creating new objects for reference-type fields. **Shallow copy** = copies the references, so both objects share the same referenced objects.

---

### 4. Private Constructor

If a constructor is declared `private`, **no object can be created from outside the class**. This is used in design patterns like **Singleton** (to ensure only one instance ever exists).

```java
class Singleton {
    private static Singleton instance;

    private Singleton() {}   // Private â€” no external instantiation

    public static Singleton getInstance() {
        if (instance == null) instance = new Singleton();
        return instance;
    }
}
```

---

### The `return` Keyword in Constructors

You can use `return` inside a constructor only to **exit early** â€” NOT to return a value.

```java
Bike(int price) {
    if (price < 0) {
        return;   // Exit constructor early â€” object is created but uninitialized
    }
    this.price = price;
}
```

---

## ðŸ§  Test Yourself â€” Constructors

**Q1.** What is the key difference between a constructor and a regular method?

> **Answer:** A constructor has no return type (not even `void`), has the same name as the class, and is called automatically by `new`. A regular method has a return type and is called explicitly.

**Q2.** If you define a parameterized constructor, can you still use `ClassName obj = new ClassName()` without arguments?

> **Answer:** **No!** Once you define any constructor, the compiler no longer provides the automatic default constructor. You must explicitly add a no-argument constructor if you want to use it.

**Q3.** What is the difference between "default constructor" and "no-argument constructor"?

> **Answer:** A **default constructor** is the one the **compiler automatically adds** if you write no constructor at all. A **no-argument constructor** is the one **you write yourself** with no parameters. Both take no arguments, but who created them differs.

**Q4.** Why use a copy constructor instead of `clone()`?

> **Answer:** Copy constructor makes a **deep copy** (new objects created for reference fields). `clone()` makes a **shallow copy** (references are shared). Copy constructors are safer and more explicit.

---

---

# 14. Garbage Collection & Finalization

## Garbage Collection

Java has **automatic garbage collection** â€” one of its biggest advantages over C/C++.

**How it works:**

1. JVM runs a background process called the **Garbage Collector (GC)**
2. GC scans memory and finds **unreferenced objects** (objects no longer pointed to by any variable)
3. Those objects are deleted, and the memory is reclaimed

```java
Bike b = new Bike("Yamaha");   // Object created in heap
b = null;                       // b no longer refers to the object
// Now the Bike object is eligible for garbage collection
```

You cannot force garbage collection (only suggest it with `System.gc()`), and you cannot predict exactly when it happens.

---

## Finalization

Sometimes before an object is destroyed, you need to do cleanup:

- Close database connections
- Release network resources
- Release file handles
- Release locks

Java provides the `finalize()` method for this:

```java
class MyClass {
    protected void finalize() {
        // Cleanup code here
        // Called by JVM just before garbage collecting this object
        System.out.println("Object being finalized");
    }
}
```

### Key points about `finalize()`:

- Called by JVM **just before** the object is garbage collected
- Uses `protected` access to prevent outside code from calling it
- NOT called when an object simply goes out of scope
- **Deprecated in Java 18** â€” use `try-with-resources` or `Cleaner` API instead
- **Java has no explicit destructors** (unlike C++)

---

## ðŸ§  Test Yourself â€” GC & Finalization

**Q1.** How does Java decide which objects to garbage collect?

> **Answer:** Objects that have **no live references** pointing to them â€” i.e., no variable in any active scope holds a reference to the object. These are "unreachable" objects.

**Q2.** Can you force garbage collection to run immediately?

> **Answer:** **No.** You can call `System.gc()` as a _suggestion_ to the JVM, but the JVM is free to ignore it. The timing of GC is non-deterministic.

**Q3.** Why was `finalize()` deprecated in Java 18?

> **Answer:** It was unreliable â€” GC timing is unpredictable, meaning cleanup might happen too late or not at all. Modern alternatives like `try-with-resources` (with `AutoCloseable`) and the `Cleaner` API provide deterministic resource cleanup.

---

---

# 15. Passing Parameters in Java

## The Core Rule: Java is Always Pass-by-Value

This is one of the most misunderstood aspects of Java. Let's get it straight.

## Case 1: Primitive Types â†’ Strict Pass-by-Value

When you pass a primitive, a **copy of the value** is made. Changes inside the method don't affect the original.

```java
void doubleIt(int x) {
    x = x * 2;   // Only changes the local copy
}

int a = 5;
doubleIt(a);
System.out.println(a);   // Still 5! The original was not changed.
```

Primitives live on the **stack**. A separate stack copy is passed.

---

## Case 2: Object References â†’ Pass-by-Value of the Reference

When you pass an object, you pass a **copy of the reference** (the memory address). The copy and the original point to the **same heap object**.

This means:

- âœ… You **CAN** modify the object's internal state (fields) through the method
- âŒ You **CANNOT** make the original variable point to a different object

```java
class Counter {
    int count = 0;
}

void increment(Counter c) {
    c.count++;         // âœ… Modifies the actual object in heap â€” visible outside
    c = new Counter(); // âŒ Replaces local copy of reference â€” original unchanged
}

Counter counter = new Counter();
increment(counter);
System.out.println(counter.count);   // Prints 1 (the increment was visible)
// counter still points to the original object (reassignment inside method had no effect)
```

---

## Summary of Java Parameter Passing

|Type|What's passed|Can modify caller's variable?|Can modify object's state?|
|---|---|---|---|
|Primitives|Copy of value|âŒ No|N/A|
|Objects|Copy of reference|âŒ No|âœ… Yes|
|Immutable objects (String, Integer...)|Copy of reference|âŒ No|âŒ No (immutable)|

## Key Conclusion from the Slides:

> Java supports **pass-by-value only.** Java doesn't support pass-by-reference. For non-primitives, a copy of the reference is passed â€” this allows modifying the object's state, but the original reference in the caller cannot be replaced.

---

## Simulating Pass-by-Reference in Java

Three techniques:

**1. Make the member variable public:**

```java
class Box { public int value; }
void increment(Box b) { b.value++; }
```

**2. Return the new value:**

```java
int add(int a, int b) { return a + b; }
result = add(result, 5);
```

**3. Single-element array:**

```java
void add(int[] a) { a[0] += 5; }
int[] num = {10};
add(num);   // num[0] is now 15
```

---

## ðŸ§  Test Yourself â€” Parameter Passing

**Q1.** You pass an `int` to a method and change it inside. Does the caller see the change?

> **Answer:** **No.** A copy of the value is made. The original is unaffected.

**Q2.** You pass an `ArrayList` to a method and call `.add()` on it inside. Does the caller see the added element?

> **Answer:** **Yes.** The reference copy still points to the same ArrayList in heap. Modifications to the object's state are visible to the caller.

**Q3.** You pass a `String` to a method and concatenate to it inside. Does the caller see the change?

> **Answer:** **No.** Strings are immutable. The concatenation creates a new String object; the local variable inside the method is updated, but the caller's String is untouched.

**Q4.** Inside a method, you do `obj = new SomeClass()`. Does this affect the caller's `obj`?

> **Answer:** **No.** You only changed your local copy of the reference. The caller's reference still points to the original object.

---

---

# 16. Polymorphism

## Two Types of Polymorphism

### 16.1 Compile-Time Polymorphism (Static / Method Overloading)

Also called **method overloading** â€” multiple methods with the same name but different parameters **in the same class**.

The compiler decides which method to call at **compile time** based on the method signature (number, type, order of parameters).

```java
class MathHelper {
    int add(int a, int b) { return a + b; }
    double add(double a, double b) { return a + b; }     // Different types
    int add(int a, int b, int c) { return a + b + c; }  // Different count
}

MathHelper m = new MathHelper();
m.add(1, 2);          // Calls first method
m.add(1.5, 2.5);      // Calls second method
m.add(1, 2, 3);       // Calls third method
```

> **Rule:** Return type alone cannot distinguish overloaded methods. Parameters must differ.

---

### 16.2 Runtime Polymorphism (Dynamic / Method Overriding)

Also called **method overriding** â€” a child class provides its own implementation of a method that's already defined in the parent class.

The JVM decides which method to call at **runtime**, based on the actual object type (not the reference type).

```java
class Animal {
    void sound() { System.out.println("Some generic sound"); }
}

class Dog extends Animal {
    @Override
    void sound() { System.out.println("Woof!"); }   // Overrides parent
}

class Cat extends Animal {
    @Override
    void sound() { System.out.println("Meow!"); }
}

Animal a = new Dog();   // Animal reference, Dog object
a.sound();              // Runtime decides: calls Dog's sound() â†’ "Woof!"

a = new Cat();
a.sound();              // â†’ "Meow!"
```

This is the power of polymorphism â€” the same reference type (`Animal`) can behave differently depending on the actual object it holds.

---

## ðŸ§  Test Yourself â€” Polymorphism

**Q1.** What is the difference between method overloading and method overriding?

> **Answer:** **Overloading** = same name, different parameters, in the _same class_, resolved at _compile time_. **Overriding** = same name and parameters, in _parent & child class_, resolved at _runtime_.

**Q2.** Can return type alone differentiate overloaded methods?

> **Answer:** **No.** Java uses parameter lists (number, type, order) to distinguish overloaded methods. Return type differences alone cause a compilation error.

**Q3.** `Animal a = new Dog();` â€” when you call `a.sound()`, which version runs?

> **Answer:** **Dog's** `sound()` method. At runtime, the JVM looks at the **actual object type** (`Dog`), not the **reference type** (`Animal`).

---

---

# 17. Recursion

## What is Recursion?

Recursion is when a **method calls itself** to solve a problem. Every recursive solution has two parts:

1. **Base case** â€” the condition that stops the recursion (prevents infinite looping)
2. **Recursive case** â€” the method calls itself with a smaller/simpler version of the problem

```java
// General recursion structure
ReturnType methodName(params) {
    if (baseCondition) {
        return result;           // Stop recursing
    }
    return methodName(smaller); // Recurse with simpler problem
}
```

---

## Example 1: Factorial

n! = n Ã— (n-1) Ã— (n-2) Ã— ... Ã— 1

```java
int factorial(int n) {
    if (n <= 1) return 1;            // Base case: 1! = 1
    return n * factorial(n - 1);    // Recursive case
}

// factorial(5) = 5 Ã— factorial(4)
//              = 5 Ã— 4 Ã— factorial(3)
//              = 5 Ã— 4 Ã— 3 Ã— factorial(2)
//              = 5 Ã— 4 Ã— 3 Ã— 2 Ã— factorial(1)
//              = 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1 = 120
```

---

## Example 2: Fibonacci Series

Series: 1, 1, 2, 3, 5, 8, 13, 21... Each number = sum of the two before it.

```java
int fib(int n) {
    if (n <= 1) return 1;              // Base case
    return fib(n - 1) + fib(n - 2);  // Recursive case
}
```

---

## What Happens Without a Base Case?

**Stack Overflow Error!** Each method call is added to the call stack. Without a base case, the stack fills up infinitely and the program crashes.

---

## ðŸ§  Test Yourself â€” Recursion

**Q1.** What two components must every recursive function have?

> **Answer:** A **base case** (stopping condition) and a **recursive case** (the self-call with a simpler input).

**Q2.** What error occurs if there is no base case?

> **Answer:** `StackOverflowError` â€” the call stack fills up infinitely.

**Q3.** What does `factorial(0)` return based on the example above?

> **Answer:** `1` â€” because `0 <= 1` triggers the base case and returns 1. (This is mathematically correct â€” 0! = 1.)

---

---

# 18. Instance Variables vs Class Variables

## Instance Variables

- Declared inside the class but **outside any method**
- Each object gets its **own separate copy**
- Created when object is created, destroyed when object is destroyed
- Accessed via object reference: `obj.variable`

```java
class Bicycle {
    int speed;    // Instance variable â€” each Bicycle has its own speed
    int gear;     // Instance variable
}

Bicycle b1 = new Bicycle();
Bicycle b2 = new Bicycle();
b1.speed = 20;    // b2.speed is still 0 â€” completely separate
```

## Class Variables (Static Variables)

- Declared with the `static` keyword
- **Shared across all instances** â€” only one copy exists in memory
- Can be accessed without creating any object: `ClassName.variable`
- Common use: counting how many objects have been created

```java
class Bicycle {
    private int speed;
    private static int numberOfBicycles = 0;   // Class variable

    Bicycle() {
        numberOfBicycles++;   // Increments shared counter
    }

    public static int getCount() {
        return numberOfBicycles;
    }
}

Bicycle b1 = new Bicycle();
Bicycle b2 = new Bicycle();
System.out.println(Bicycle.getCount());   // 2
```

## Class Methods (Static Methods)

- Declared with `static`
- Belong to the class, not to any instance
- Called via `ClassName.methodName()`
- **CANNOT** access instance variables directly (no `this` reference)
- **CAN** access static variables and static methods

```java
class MathUtil {
    public static int square(int n) {
        return n * n;   // No instance needed
    }
}

int result = MathUtil.square(5);   // Call without creating object
```

## Access Rules Summary

|Caller|Can access instance members?|Can access static members?|
|---|---|---|
|Instance method|âœ… Yes|âœ… Yes|
|Static method|âŒ No (must use object ref)|âœ… Yes|

---

## ðŸ§  Test Yourself â€” Instance vs Class Members

**Q1.** If 5 objects are created from a class, how many copies of an instance variable exist? How many copies of a static variable?

> **Answer:** **5 copies** of the instance variable (one per object). **1 copy** of the static variable (shared by all).

**Q2.** Can a static method call an instance method directly?

> **Answer:** **No.** Static methods don't have a `this` reference. They must use an object reference: `someObj.instanceMethod()`.

**Q3.** How do you access a static method?

> **Answer:** `ClassName.methodName()` â€” no object creation needed.

---

---

# 19. The `this` Keyword

The `this` keyword in Java refers to the **current object** â€” the instance on which the method or constructor is being called.

## Six Uses of `this`

### 1. Refer to Current Class Instance Variable (Disambiguation)

When a parameter name shadows an instance variable:

```java
class Person {
    String name;
    int age;

    Person(String name, int age) {
        this.name = name;   // this.name = instance var; name = parameter
        this.age = age;
    }
}
```

Without `this.name`, `name = name` would just assign the parameter to itself â€” a bug!

### 2. Invoke Current Class Method

```java
class MyClass {
    void method1() { System.out.println("Method 1"); }
    void method2() { this.method1(); }  // Explicitly calling method1 on this object
}
```

### 3. Invoke Current Class Constructor (Constructor Chaining)

```java
class Bike {
    String model;
    int price;

    Bike() {
        this("Default Model", 50000);   // Calls parameterized constructor
    }

    Bike(String model, int price) {
        this.model = model;
        this.price = price;
    }
}
```

> `this()` must be the **first statement** in the constructor.

### 4. Pass `this` as a Method Argument

```java
void display(Person p) { System.out.println(p.name); }

class Person {
    void show() {
        display(this);   // Pass the current object
    }
}
```

### 5. Pass `this` as Constructor Argument

Useful when one object needs to know about the object that created it.

### 6. Return Current Object from a Method

Useful for **method chaining** (builder pattern):

```java
class Builder {
    String name;

    Builder setName(String name) {
        this.name = name;
        return this;   // Return current object for chaining
    }
}

Builder b = new Builder().setName("Alice");
```

---

## ðŸ§  Test Yourself â€” `this` Keyword

**Q1.** What does `this` refer to?

> **Answer:** The **current object** â€” the instance on which the method or constructor was invoked.

**Q2.** If a constructor parameter is named `speed` and there's also an instance variable named `speed`, how do you distinguish them?

> **Answer:** `this.speed` refers to the instance variable; `speed` (without `this`) refers to the parameter.

**Q3.** Where must `this()` (constructor chaining call) appear?

> **Answer:** It must be the **very first statement** in the constructor body.

---

---

# 20. Exception Handling

## What is an Exception?

An **exception** is an unexpected event that occurs during program execution and **disrupts the normal flow** of the program. Examples:

- Dividing by zero (`ArithmeticException`)
- Accessing array out of bounds (`ArrayIndexOutOfBoundsException`)
- Null pointer dereference (`NullPointerException`)
- File not found (`FileNotFoundException`)

---

## The Exception Flow

1. An error occurs during execution
2. JVM **creates an exception object** (containing error info: type, location, message)
3. JVM **throws** the exception â€” hands it to the runtime
4. The runtime looks for an **exception handler** (a catch block) starting from the current method and going up the call stack
5. If no handler found all the way to `main()`, the program terminates

---

## The Four Keywords

### `try` â€” The protected block

```java
try {
    // Code that might throw an exception
    int result = 10 / 0;
}
```

### `catch` â€” The exception handler

```java
catch (ArithmeticException e) {
    System.out.println("Cannot divide by zero!");
    System.out.println(e.getMessage());
}
```

### `finally` â€” Always executes

```java
finally {
    // Runs whether exception occurred or not
    // Perfect for closing files, DB connections, etc.
    System.out.println("Cleanup done");
}
```

### Complete try-catch-finally:

```java
try {
    int[] arr = new int[5];
    arr[10] = 3;    // ArrayIndexOutOfBoundsException!
}
catch (ArrayIndexOutOfBoundsException e) {
    System.out.println("Array index error: " + e.getMessage());
}
catch (Exception e) {
    System.out.println("General error: " + e.getMessage());
}
finally {
    System.out.println("This always runs");
}
```

### `throw` â€” Manually throw an exception

```java
void authenticate(String password) {
    if (password == null) {
        throw new IllegalArgumentException("Password cannot be null");
    }
}
```

### `throws` â€” Declare that a method may throw exceptions

```java
void readFile(String path) throws IOException, FileNotFoundException {
    // This method may throw these â€” caller must handle or re-declare
}
```

---

## Important Rules About `finally`

- `finally` **always executes**, even if an exception is thrown and not caught
- The **ONLY exception**: `System.exit(0)` inside `try/catch` â€” this terminates the JVM, so `finally` doesn't run
- You cannot have code between `try`, `catch`, and `finally` blocks

---

## Exception Methods (from `Throwable`)

|Method|Description|
|---|---|
|`getMessage()`|Returns the error message|
|`printStackTrace()`|Prints the full stack trace|
|`getStackTrace()`|Returns array of stack trace elements|
|`toString()`|Returns exception name + message|

---

## Built-in Exceptions

|Exception|When It Occurs|
|---|---|
|`ArithmeticException`|Arithmetic error (e.g., divide by zero)|
|`ArrayIndexOutOfBoundsException`|Array accessed with invalid index|
|`NullPointerException`|Accessing member of null object|
|`NumberFormatException`|String â†’ number conversion fails|
|`ClassNotFoundException`|Class definition not found|
|`FileNotFoundException`|File not found or inaccessible|
|`IOException`|I/O operation failed|
|`StackOverflowError`|Infinite recursion|
|`StringIndexOutOfBoundsException`|String index invalid|
|`InterruptedException`|Thread interrupted while sleeping/waiting|

---

## ðŸ§  Test Yourself â€” Exception Handling

**Q1.** What is the difference between `throw` and `throws`?

> **Answer:** `throw` is used to **actually throw an exception object** at a specific point in your code. `throws` is a declaration in the method signature that tells callers the method **might throw** these exceptions â€” they must handle or re-declare them.

**Q2.** In a try-catch-finally block, if both `catch` and `finally` blocks have code, in what order do they execute?

> **Answer:** The exception is caught by `catch`, that block runs, **then** `finally` runs. `finally` always runs last (after catch).

**Q3.** Does `finally` run if `System.exit(0)` is called inside `try`?

> **Answer:** **No.** `System.exit(0)` terminates the JVM immediately â€” no further code (including `finally`) runs.

**Q4.** Can you have multiple `catch` blocks for one `try` block?

> **Answer:** **Yes.** Multiple catch blocks can handle different exception types. They are checked in order â€” put more specific exceptions before more general ones (e.g., `NullPointerException` before `Exception`).

**Q5.** What happens if an exception is thrown in a method and no catch block is present in that method?

> **Answer:** The exception **propagates up the call stack** to the calling method. If no handler is found all the way up to `main()`, the program terminates with an unhandled exception.

---

---

# 21. Inheritance (All Types)

## What is Inheritance?

Inheritance is the OOP mechanism where one class (child/subclass) **acquires the properties and behaviors** of another class (parent/superclass).

Represents the **IS-A relationship**: `Dog IS-A Animal`

```java
class Animal {
    String name;
    void eat() { System.out.println(name + " is eating"); }
}

class Dog extends Animal {   // Dog inherits from Animal
    void bark() { System.out.println(name + " says Woof!"); }
}

Dog d = new Dog();
d.name = "Rex";    // Inherited from Animal
d.eat();           // Inherited method
d.bark();          // Dog's own method
```

**Why use inheritance?**

- **Code Reuse** â€” write once in parent, use in all children
- **Polymorphism** â€” method overriding enables runtime polymorphism
- **Extensibility** â€” extend existing code without rewriting it

---

## Types of Inheritance

### 1. Single Inheritance

```
A â† B (B extends A)
```

One class inherits from exactly one parent.

### 2. Multilevel Inheritance

```
A â† B â† C (C extends B, B extends A)
```

A chain â€” grandparent â†’ parent â†’ child.

### 3. Hierarchical Inheritance

```
     A
    / \
   B   C     (B and C both extend A)
```

Multiple children inherit from one parent.

### 4. Multiple Inheritance â€” âŒ NOT SUPPORTED for Classes in Java

```
A   B
 \ /
  C     (C extends A AND B â€” NOT allowed)
```

Java does NOT allow a class to extend multiple classes. This prevents the **Diamond Problem**. However, multiple inheritance IS supported through **interfaces**.

### 5. Hybrid Inheritance â€” âŒ NOT SUPPORTED

A combination of hierarchical and multiple inheritance â€” also not allowed for classes.

---

## The `super` Keyword

`super` refers to the **parent class**. Used to:

**1. Access parent's variable:**

```java
class Parent { int x = 10; }
class Child extends Parent {
    int x = 20;
    void show() {
        System.out.println(x);        // 20 (child's x)
        System.out.println(super.x);  // 10 (parent's x)
    }
}
```

**2. Call parent's method:**

```java
class Child extends Parent {
    void show() {
        super.show();   // Calls parent's show() method
        // Child-specific code
    }
}
```

**3. Call parent's constructor:**

```java
class Child extends Parent {
    Child(int a, int b) {
        super(a);    // Must be FIRST statement â€” calls Parent's constructor
        this.b = b;
    }
}
```

> **Important:** The `super()` call is implicit in Java. Even if you don't write it, the parent's no-arg constructor is automatically called first. But if the parent has only parameterized constructors, you MUST explicitly call `super(params)`.

---

## Access Modifiers and Inheritance

|Modifier|Inherited by Child?|Accessible by Child?|
|---|---|---|
|`public`|âœ… Yes|âœ… Yes, directly|
|`protected`|âœ… Yes|âœ… Yes, directly|
|`default`|âœ… Yes (same package)|âœ… Yes (same package)|
|`private`|âŒ No (not directly)|âŒ No (use getters/setters)|

---

## ðŸ§  Test Yourself â€” Inheritance

**Q1.** What keyword is used to inherit a class in Java?

> **Answer:** `extends`. Example: `class Dog extends Animal`

**Q2.** Why doesn't Java support multiple inheritance for classes?

> **Answer:** To avoid the **Diamond Problem** â€” if two parent classes have the same method, the child wouldn't know which one to use. Java handles this through interfaces instead.

**Q3.** Where must `super()` appear in a constructor?

> **Answer:** As the **first statement** in the constructor body.

**Q4.** Can private methods of a parent be called using `super` in the child class?

> **Answer:** **No.** Private members are not inherited and are not accessible from child classes. You must use public/protected getters if you need access.

**Q5.** What happens if you don't write `super()` and the parent has no no-arg constructor?

> **Answer:** **Compilation error.** Java implicitly calls `super()` (no-arg), but if the parent only has parameterized constructors, you must explicitly call `super(arguments)`.

---

---

# 22. Method Overloading & Overriding

## Overloading (Compile-time Polymorphism)

**Same class, same name, different parameters.**

```java
class Printer {
    void print(int i) { System.out.println("int: " + i); }
    void print(double d) { System.out.println("double: " + d); }
    void print(String s) { System.out.println("String: " + s); }
}
```

## Overriding (Runtime Polymorphism)

**Parent and child class, same name AND same parameters.**

```java
class Shape {
    double area() { return 0; }
}

class Circle extends Shape {
    double radius;
    @Override
    double area() { return Math.PI * radius * radius; }  // Overrides parent
}
```

## Comparison Table

|Feature|Overloading|Overriding|
|---|---|---|
|Also called|Compile-time polymorphism|Runtime polymorphism|
|Location|Same class|Parent & child class|
|Method name|Same|Same|
|Parameters|Must differ|Must be same|
|Return type|Can differ|Must be same (or covariant)|
|`@Override` annotation|Not used|Recommended|
|Resolved at|Compile time|Runtime|
|Access modifier|Can be anything|Can't be more restrictive|

## `final` Methods

A method declared `final` **cannot be overridden** by any subclass:

```java
class Animal {
    final void breathe() {
        System.out.println("Breathing...");   // Cannot be overridden
    }
}
```

---

## ðŸ§  Test Yourself â€” Overloading & Overriding

**Q1.** Can you overload a method by changing only its return type?

> **Answer:** **No.** Java uses parameter lists (not return type) to distinguish overloaded methods. Changing only the return type causes a compilation error.

**Q2.** You override a method in a child class. The parent method is `public`. Can you make the child's version `private`?

> **Answer:** **No.** When overriding, you cannot make the access modifier **more restrictive**. You can make it less restrictive (private â†’ protected â†’ public) but not more.

**Q3.** What is the `@Override` annotation for?

> **Answer:** It tells the compiler you intend to override a parent method. If you make a mistake (e.g., wrong parameters), the compiler will catch it and give an error instead of silently treating it as a new method.

---

---

# 23. Abstract Classes

## What is an Abstract Class?

An abstract class is a class declared with the `abstract` keyword. It represents an **incomplete concept** â€” a partially implemented class meant to be extended.

Key feature: It can have **abstract methods** (no body) AND **concrete methods** (with body).

```java
abstract class Shape {
    String color;

    // Concrete method â€” has a body
    void setColor(String c) { this.color = c; }

    // Abstract method â€” NO body, subclasses MUST implement it
    abstract double area();
}
```

---

## Rules for Abstract Classes

1. Declared with `abstract` keyword
2. Can have abstract AND non-abstract (concrete) methods
3. **Cannot be instantiated** â€” you cannot do `new Shape()`
4. Can have constructors (but only callable via `super()`)
5. Can have static methods and final methods
6. Subclass **must implement ALL abstract methods** â€” unless the subclass is also abstract

```java
class Circle extends Shape {
    double radius;

    Circle(double r) { this.radius = r; }

    @Override
    double area() {                          // MUST implement abstract method
        return Math.PI * radius * radius;
    }
}

// Now you can do this:
Shape s = new Circle(5.0);   // Polymorphism via abstract class reference
System.out.println(s.area());
```

---

## Why Use Abstract Classes?

1. **Enforced uniformity** â€” Every subclass MUST implement the abstract methods â€” like a contract
2. **Centralized logic** â€” Common behavior lives in the abstract class once; subclasses don't repeat it
3. **Polymorphism** â€” You can hold a collection of different types as a single abstract type

---

## Abstract Class Example â€” Healthcare System

```java
abstract class HealthProfessional {
    String name;

    HealthProfessional(String name) { this.name = name; }

    // Common method â€” all professionals check in
    void checkIn() {
        System.out.println(name + " has checked in.");
    }

    // Abstract â€” each professional performs duty differently
    abstract void performDuty();
}

class Doctor extends HealthProfessional {
    Doctor(String name) { super(name); }

    @Override
    void performDuty() {
        System.out.println(name + " is examining patients.");
    }
}

class Surgeon extends HealthProfessional {
    Surgeon(String name) { super(name); }

    @Override
    void performDuty() {
        System.out.println(name + " is performing surgery.");
    }
}
```

---

## ðŸ§  Test Yourself â€” Abstract Classes

**Q1.** Can you instantiate an abstract class?

> **Answer:** **No.** `new AbstractClass()` causes a compilation error. You must instantiate a concrete subclass.

**Q2.** Can an abstract class have non-abstract methods?

> **Answer:** **Yes.** Abstract classes can have both abstract methods (no body) and concrete methods (with body). That's what distinguishes them from interfaces.

**Q3.** If a subclass doesn't implement all abstract methods, what must it be?

> **Answer:** **Also abstract.** You can defer implementation by making the subclass abstract too, but eventually a concrete class must implement them all.

**Q4.** Can an abstract class have a constructor?

> **Answer:** **Yes.** Though you can't instantiate the abstract class directly, its constructor runs via `super()` when a subclass is instantiated.

---

---

# 24. Interfaces

## What is an Interface?

An interface is a **fully abstract contract** that defines what a class must do, without specifying how. It's a promise: "Any class that implements me WILL have these methods."

```java
interface Printable {
    void print();         // Implicitly public and abstract
    void printPDF();
}
```

---

## Key Properties of Interfaces

- All methods are implicitly `public` and `abstract` (before Java 8)
- All variables are implicitly `public`, `static`, and `final` (constants)
- **Cannot be instantiated** directly
- A class uses `implements` to implement an interface
- A class **CAN implement multiple interfaces** (solving the multiple inheritance problem)
- An interface **CAN extend multiple interfaces**

---

## Implementing an Interface

```java
interface Animal {
    void makeSound();
    void move();
}

class Dog implements Animal {
    @Override
    public void makeSound() {
        System.out.println("Woof!");
    }

    @Override
    public void move() {
        System.out.println("Running on 4 legs");
    }
}
```

---

## Multiple Interfaces

```java
interface Flyable {
    void fly();
}

interface Swimmable {
    void swim();
}

class Duck implements Flyable, Swimmable {
    public void fly() { System.out.println("Duck is flying"); }
    public void swim() { System.out.println("Duck is swimming"); }
}
```

---

## Default Methods (Java 8+)

Before Java 8, all interface methods had to be abstract. Java 8 introduced **default methods** â€” methods with an actual body in the interface:

```java
interface Vehicle {
    void start();

    default void honk() {           // Default method â€” has a body
        System.out.println("Beep!");
    }
}
```

Why? To allow **evolving interfaces without breaking existing implementations**. Old classes that already implement the interface don't need to add the new default method.

---

## The Diamond Problem with Default Methods

If two interfaces have a default method with the same name and a class implements both, you MUST override it:

```java
interface A { default void hello() { System.out.println("Hello from A"); } }
interface B { default void hello() { System.out.println("Hello from B"); } }

class C implements A, B {
    @Override
    public void hello() {
        A.super.hello();  // Explicitly choose which one to use
        // OR provide your own implementation
    }
}
```

---

## Extending Interfaces

```java
interface Animal { void breathe(); }

interface Pet extends Animal {   // Interface extending interface
    void play();
}

// A class implementing Pet must implement BOTH breathe() AND play()
```

---

## ðŸ§  Test Yourself â€” Interfaces

**Q1.** What keyword does a class use to implement an interface?

> **Answer:** `implements`. Example: `class Dog implements Animal`

**Q2.** Can a class implement more than one interface?

> **Answer:** **Yes!** This is how Java achieves multiple inheritance of type. `class Duck implements Flyable, Swimmable`

**Q3.** What visibility are interface methods by default?

> **Answer:** `public` and `abstract` (implicitly).

**Q4.** What is a default method in an interface?

> **Answer:** A method with a body inside an interface, introduced in Java 8. It provides a default implementation that classes don't have to override (unless they want to). Used for backward-compatible interface evolution.

**Q5.** Can an interface extend another interface?

> **Answer:** **Yes.** Using `extends`. An interface can even extend multiple interfaces: `interface C extends A, B`

---

---

# 25. Abstract Class vs Interface

## When to Use Which?

|Feature|Abstract Class|Interface|
|---|---|---|
|Methods|Abstract + concrete|Abstract + default (Java 8+)|
|Variables|Any type|Only `public static final` constants|
|Constructors|âœ… Yes|âŒ No|
|Multiple inheritance|âŒ No (extends one)|âœ… Yes (implements many)|
|Relationship|IS-A (related classes)|CAN-DO / implements (unrelated classes)|

## Use an Abstract Class when:

- You want to share code among **closely related** classes
- Common state (fields) and some common behavior exist
- You need non-public, non-static fields
- Base class should NOT be instantiated but subclasses should share logic

## Use an Interface when:

- **Unrelated** classes need to share a contract (e.g., `Comparable`, `Serializable`)
- You want to define a capability/role without caring about who implements it
- You need multiple inheritance of type

---

## Advantages of Abstraction (General)

- Reduces complexity and increases code readability
- Improves maintainability, modularity, reusability, flexibility
- Separates "what" from "how" â€” callers only see the interface

## Disadvantages of Abstraction

- Can increase complexity if overused or misused
- Additional layers may reduce performance (indirection)
- Can be hard to understand for beginners

---

---

# 26. Nested Classes

A **nested class** is a class defined inside another class. Good for grouping classes that are only used in one place.

## Types

### 1. Static Nested Class

```java
class Outer {
    static int x = 10;

    static class StaticNested {
        void display() {
            System.out.println("x = " + x);   // Can access outer static members
        }
    }
}

Outer.StaticNested obj = new Outer.StaticNested();  // No Outer instance needed
```

### 2. Inner Class (Non-Static)

```java
class Outer {
    int y = 20;

    class Inner {
        void display() {
            System.out.println("y = " + y);   // Can access outer instance members
        }
    }
}

Outer outer = new Outer();
Outer.Inner inner = outer.new Inner();   // Needs Outer instance
```

### 3. Method-Local Inner Class

A class defined inside a method â€” visible only within that method.

---

---

# 27. Arrays & the Arrays Utility Class

## Arrays â€” Basics

```java
// Declaration
int[] arr;

// Allocation
arr = new int[5];

// Declaration + Allocation
int[] arr = new int[5];

// Declaration + Initialization
int[] arr = {10, 20, 30, 40, 50};
```

- Index starts at 0
- `arr.length` gives the size
- Accessing invalid index â†’ `ArrayIndexOutOfBoundsException`

## Iterating Arrays

```java
// Traditional for loop
for (int i = 0; i < arr.length; i++) {
    System.out.println(arr[i]);
}

// Enhanced for loop
for (int num : arr) {
    System.out.println(num);
}
```

## Multi-Dimensional Arrays

```java
int[][] matrix = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
System.out.println(matrix[1][2]);   // 6 (row 1, col 2)
```

---

## The `Arrays` Utility Class (`java.util.Arrays`)

```java
import java.util.Arrays;
```

|Method|Description|Example|
|---|---|---|
|`Arrays.sort(arr)`|Sorts in ascending order|`Arrays.sort(ints)`|
|`Arrays.copyOf(arr, len)`|Copies first `len` elements|`Arrays.copyOf(source, 5)`|
|`Arrays.fill(arr, val)`|Fills array with `val`|`Arrays.fill(arr, 99)`|
|`Arrays.binarySearch(arr, key)`|Binary search (must be sorted first)|`Arrays.binarySearch(arr, 6)`|
|`Arrays.equals(arr1, arr2)`|Checks if arrays are equal|Returns `true/false`|
|`Arrays.toString(arr)`|Converts array to readable String|`[1, 2, 3, 4]`|

### Sorting in Descending Order:

```java
import java.util.Arrays;
import java.util.Collections;

Integer[] arr = {5, 2, 8, 1};   // Must use Integer[] (not int[])
Arrays.sort(arr, Collections.reverseOrder());
```

---

## ðŸ§  Test Yourself â€” Arrays

**Q1.** What is the index of the last element in an array of size 10?

> **Answer:** **Index 9** (arrays are 0-indexed: 0 to 9).

**Q2.** You want to sort in descending order using `Arrays.sort()`. What type must the array be?

> **Answer:** An **object array** â€” e.g., `Integer[]` instead of `int[]`, because `Collections.reverseOrder()` requires objects (for the Comparator).

**Q3.** Before using `Arrays.binarySearch()`, what must you do to the array?

> **Answer:** **Sort it first** (using `Arrays.sort()`). Binary search only works correctly on sorted arrays.

---

---

# 28. Java Collections Framework (JCF)

## What is the JCF?

The Java Collections Framework is a **unified architecture** in `java.util` providing interfaces, implementation classes, and algorithms for managing groups of objects efficiently.

Unlike arrays:

- **Dynamic size** â€” can grow or shrink automatically
- **Rich API** â€” sorting, searching, iteration built-in
- **Type-safe** â€” with generics

## JCF Hierarchy Overview

```
Collection (interface)
  â”œâ”€â”€ List (interface)
  â”‚     â”œâ”€â”€ ArrayList
  â”‚     â”œâ”€â”€ LinkedList
  â”‚     â”œâ”€â”€ Vector
  â”‚     â””â”€â”€ Stack
  â”œâ”€â”€ Set (interface)
  â”‚     â”œâ”€â”€ HashSet
  â”‚     â””â”€â”€ TreeSet
  â””â”€â”€ Queue (interface)

Map (interface)
  â”œâ”€â”€ HashMap
  â””â”€â”€ TreeMap
```

---

## List Interface

The `List` is an **ordered collection** that allows duplicate elements and sequential access by index.

### ArrayList â€” Most Commonly Used

```java
import java.util.ArrayList;

ArrayList<String> list = new ArrayList<>();

// Add elements
list.add("Apple");
list.add("Banana");
list.add("Cherry");

// Access
System.out.println(list.get(1));   // "Banana"

// Modify
list.set(0, "Avocado");

// Remove
list.remove("Banana");

// Size
System.out.println(list.size());   // 2

// Iterate
for (String s : list) {
    System.out.println(s);
}
```

### Important ArrayList Methods

|Method|Description|
|---|---|
|`add(element)`|Appends to end|
|`add(index, element)`|Inserts at index|
|`get(index)`|Gets element at index|
|`set(index, element)`|Replaces element|
|`remove(index)` or `remove(obj)`|Removes element|
|`size()`|Number of elements|
|`contains(obj)`|Returns true if element exists|
|`indexOf(obj)`|Index of first occurrence|
|`clear()`|Removes all elements|
|`isEmpty()`|Returns true if empty|
|`sort(Comparator)`|Sorts the list|

> **Note:** ArrayList stores **objects**, not primitives. For primitives, Java uses autoboxing automatically: `list.add(5)` â†’ actually stores `Integer.valueOf(5)`.

---

## Stack

The Stack class implements LIFO (Last-In, First-Out) behavior:

```java
import java.util.Stack;

Stack<Integer> stack = new Stack<>();
stack.push(1);      // Add to top
stack.push(2);
stack.push(3);
System.out.println(stack.pop());    // 3 â€” removes and returns top
System.out.println(stack.peek());   // 2 â€” views top without removing
```

---

## ðŸ§  Test Yourself â€” JCF

**Q1.** What is the key advantage of ArrayList over a regular array?

> **Answer:** ArrayList has **dynamic size** â€” it automatically resizes as you add/remove elements. Arrays have a fixed size set at creation.

**Q2.** Can an ArrayList store primitive types like `int`?

> **Answer:** Not directly â€” but through **autoboxing**, Java automatically converts `int` to `Integer` when you call `list.add(5)`.

**Q3.** What does `list.get(0)` return?

> **Answer:** The element at **index 0** â€” the first element in the list.

---

---

# 29. The Java Object Class

The `Object` class is the **root of the entire Java class hierarchy**. Every class in Java either directly or indirectly extends `Object`. This means every Java object inherits these methods:

|Method|Description|
|---|---|
|`getClass()`|Returns the runtime class of the object|
|`toString()`|Returns string representation of the object|
|`equals(Object obj)`|Checks equality (by default: reference equality)|
|`hashCode()`|Returns hash code value|
|`clone()`|Creates a copy of the object|
|`wait()`, `notify()`, `notifyAll()`|Thread coordination methods|
|`finalize()`|Called before GC (deprecated)|

### Overriding `toString()`:

```java
class Person {
    String name;
    int age;

    @Override
    public String toString() {
        return "Person{name=" + name + ", age=" + age + "}";
    }
}

Person p = new Person();
p.name = "Alice";
p.age = 25;
System.out.println(p);   // Automatically calls toString() â†’ "Person{name=Alice, age=25}"
```

### Overriding `equals()`:

```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (!(obj instanceof Person)) return false;
    Person other = (Person) obj;
    return name.equals(other.name) && age == other.age;
}
```

---

---

# 30. Architectural Patterns

## What are Architectural Patterns?

Architectural patterns are **high-level, reusable solutions** to common software design problems. They define how components of a system are structured and interact.

---

## 30.1 MVC (Model-View-Controller)

MVC is the most fundamental architectural pattern, separating an application into three interconnected layers:

### Model â€” Data & Business Logic

- Stores and manages data
- Defines business rules and validation
- Manages database interactions
- Notifies other components when data changes

### View â€” User Interface & Presentation

- Displays data to users
- Handles UI elements, layout, styling
- Responds to user interactions (buttons, forms, etc.)
- Updates when data changes

### Controller â€” Application Logic & Coordination

- Processes user input
- Updates the Model based on actions
- Selects appropriate Views to display
- Acts as the liaison/brain of the application

### MVC Flow:

```
User â†’ View â†’ Controller â†’ Model â†’ View (updated)
```

1. User interacts with the View
2. View sends input to the Controller
3. Controller processes input, updates Model
4. Model notifies View of changes
5. View re-renders with new data

### Real-Life Analogy â€” Thanksgiving Dinner:

- **Model** = Refrigerator (all the ingredients/data)
- **Controller** = Recipe (logic: which ingredients to use, when)
- **View** = Table setting & plates (what the guests see/interact with)

---

## 30.2 Layered (N-Tier) Pattern

Organizes software into **horizontal, independent layers**:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Presentation Layer â”‚  â† UI (web, mobile, desktop)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Business Layer     â”‚  â† Application logic, rules
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Persistence Layer  â”‚  â† Data access (DAO, repositories)
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   Database Layer     â”‚  â† Actual data storage
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

- Each layer has an **isolated, specific responsibility**
- A layer only communicates with the layer directly above/below it
- Changes in one layer don't cascade to others

---

## 30.3 Microservices Pattern

Application is broken into **small, independent, loosely coupled services**. Each service:

- Has its own database
- Can be deployed independently
- Communicates with others via APIs
- Handles one specific business capability (auth service, payment service, etc.)

**Benefits:** Scalability, resilience, independent deployment, technology diversity.

---

## 30.4 Event-Driven Pattern

Applications communicate **asynchronously by producing and consuming events**.

- **Event** = a significant state change ("order placed", "payment received")
- A **central broker** (like Kafka, RabbitMQ) routes messages
- Services are decoupled â€” they don't call each other directly

**Benefits:** Highly scalable, flexible, real-time processing.

---

## ðŸ§  Test Yourself â€” Architectural Patterns

**Q1.** In MVC, which component handles user input?

> **Answer:** The **Controller** processes user input, updates the Model, and coordinates what View to display.

**Q2.** What is the key benefit of the Layered pattern?

> **Answer:** **Separation of concerns** â€” each layer has isolated responsibilities. Changes in one layer don't break other layers.

**Q3.** What is the main difference between MVC and Microservices?

> **Answer:** MVC is a **code-level architectural pattern** for organizing a single application's structure. Microservices is a **system-level deployment pattern** for breaking a large application into independent, separately deployable services.

**Q4.** In which MVC component would you place database query code?

> **Answer:** The **Model** â€” it handles data management, business rules, and database interactions.

---

---

# ðŸŽ“ Final Mega Quiz â€” Test All Your Knowledge

Work through these on your own before reading the answers!

---

**Q1.** What is the output of:

```java
String s = "Hello";
s.toUpperCase();
System.out.println(s);
```

**Answer:** `Hello` â€” Strings are immutable. `toUpperCase()` returns a NEW string; it doesn't modify `s`. To see "HELLO", you'd need `s = s.toUpperCase()`.

---

**Q2.** A class has no constructor written. You call `new MyClass()`. What happens? **Answer:** The compiler automatically provides a **default constructor** (no-args). The object is created with default values for all fields (0 for numbers, `null` for objects, `false` for boolean).

---

**Q3.** What is the difference between `==` and `.equals()` for Strings? **Answer:** `==` compares **references** (memory addresses). `.equals()` compares **content**. Always use `.equals()` to compare String values.

---

**Q4.** An abstract class has 3 abstract methods. A subclass implements only 2. What must the subclass be? **Answer:** **Abstract** â€” a class must implement ALL abstract methods of its parent, or itself be declared abstract.

---

**Q5.** Can a Java class implement 2 interfaces and extend 1 abstract class simultaneously? **Answer:** **Yes!** `class MyClass extends AbstractBase implements Interface1, Interface2` â€” this is perfectly valid and common.

---

**Q6.** What is the output of:

```java
void increment(int x) { x = x + 10; }
int a = 5;
increment(a);
System.out.println(a);
```

**Answer:** `5` â€” `int` is a primitive. A copy is passed. The original `a` is unchanged.

---

**Q7.** What is the output of:

```java
try {
    System.out.println("A");
    throw new RuntimeException();
} catch (Exception e) {
    System.out.println("B");
} finally {
    System.out.println("C");
}
System.out.println("D");
```

**Answer:** `A B C D` â€” A (try), exception thrown, B (catch), C (finally always runs), D (program continues after the try-catch block).

---

**Q8.** What is the core idea behind the `static` keyword in Java? **Answer:** `static` means the member belongs to the **class itself** rather than any instance. Only ONE copy exists, shared by all objects. Can be accessed without creating any object.

---

**Q9.** Define "deep copy" vs "shallow copy". **Answer:** A **shallow copy** duplicates only the object itself â€” reference fields still point to the **same** underlying objects. A **deep copy** duplicates everything recursively â€” reference fields get new copies of their referenced objects too.

---

**Q10.** In the MVC pattern, if you need to add a new field to your data model, which component(s) must you change? **Answer:** Primarily the **Model** (to store the new field) and likely the **View** (to display it). The **Controller** may need minor updates if it processes that field. This illustrates MVC's separation of concerns â€” you know exactly where changes go.

---

---

_ðŸ“š This notebook covers all topics from OOAD with Java Unit II. Study each section, work through the test questions, and revisit any topic you find challenging._

_Happy Learning! ðŸš€_