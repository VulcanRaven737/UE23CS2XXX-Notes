# ðŸ“˜ Master Notebook: Object-Oriented Analysis and Design (OOAD) & UML

## Module 1: Software Development Life Cycles (SDLC) & Paradigms

### Traditional SDLC and SSADM

Before the shift to modern paradigms, traditional models like **SSADM** (Structured Systems Analysis and Design Method) were widely used, particularly in the UK. SSADM follows a rigid, cascading waterfall approach with distinct stages:

1. Feasibility stage
2. Requirements analysis
3. Definition of requirements
4. Logical system specification
5. Physical design

### Software Development Life Cycle (SDLC) Models

Understanding how software is built is critical before designing it:

- **Waterfall Model:** A linear, sequential process (Requirements -> Design -> Implementation -> Testing -> Deployment -> Maintenance).
    - _Advantages:_ Easy to understand, rigid phases with specific deliverables, and works well for small projects with well-understood requirements.
    - _Disadvantages:_ Extremely difficult to go back and fix errors, no working software is produced until late in the cycle, and it is highly inefficient for complex, object-oriented projects.
- **V-Model:** A model where development phases are paired with testing phases (e.g., Business Requirements align with Acceptance Testing; High-level Design aligns with System Integration Testing). This emphasizes Verification and Validation.
- **Prototyping Model:** A dummy version of the system is built to understand requirements. These can be throw-away prototypes or evolutionary ones that eventually become the final product.
- **Incremental Model:** Requirements are partitioned, and each partition has its own development lifecycle (often using miniature waterfalls). Successive deliveries add functionality (like painting the Mona Lisa piece by piece).
- **Iterative (Evolutionary) Model:** Starts with a skeleton product built with dummy modules. Through rapid prototyping and user feedback, the system undergoes successive refinement until complete (like sketching a picture before filling in the details).

### The Shift: Procedural vs. Object-Oriented Paradigms

All programs consist of code and data.

- **Procedural Programming:** Organizes the program around "what is happening" (the code). It is a linear, top-down approach focusing on procedures and functions acting upon global and local data. As programs grow complex, this model breaks down because data is exposed globally, causing security issues and making changes difficult.
- **Object-Oriented Programming (OOP):** Organizes the program around "who is being affected" (the data). The program is modeled as a group of interacting objects.
    - Data is hidden (encapsulated) and not accessed by external functions directly.
    - Objects communicate through well-defined interfaces (methods).
    - It uses a bottom-up approach, allowing new data and functions to be added easily.

_Note on Terminology:_ **Object-Based Languages** (like JavaScript or early VB) support objects and encapsulation but do _not_ strictly support inheritance or polymorphism. **Object-Oriented Languages** (like Java, C++, Python) support all OOP features, including inheritance and polymorphism.

### Analysis vs. Design

- **Object-Oriented Analysis (OOA):** Focuses on investigating the problem to determine _what_ the system does (doing the right thing). It involves finding and describing objects in the problem domain (e.g., identifying a `Book` concept in a library).
- **Object-Oriented Design (OOD):** Focuses on the conceptual solution to determine _how_ the system does it (doing the thing right). It involves defining logical software objects (classes, interfaces) that will be implemented in code (e.g., creating a `Book` class with `issue()` and `return()` methods).

---

## Module 2: Requirements Engineering & UML Foundations

### Requirements Engineering (RE)

A requirement is a condition or capability needed by a user to solve a problem, specifying _what_ the system must exhibit, not _how_. RE is the process of defining, documenting, and maintaining these requirements.

- **Key Activities:** Understanding the problem, classifying requirements (Functional vs. Non-Functional), modelling them, analyzing conflicts (e.g., cost vs. functionality), negotiating, and identifying risks.
- **MoSCoW Prioritization:** Requirements are prioritized into **M**ust have, **S**hould have, **C**ould have, and **W**on't have.

### The Unified Modeling Language (UML)

To understand requirements, we build modelsâ€”simplified abstractions of reality that hide non-essential characteristics. UML is a standardized visual modeling language created by the "Three Amigos" (Grady Booch, Ivar Jacobson, Jim Rumbaugh) to specify, visualize, and document software systems.

#### The Conceptual Model of UML

UML is built on three major elements:

1. **Things (The vocabulary/building blocks):**
    - _Structural:_ The nouns (Classes, Interfaces, Use Cases, Components, Nodes).
    - _Behavioral:_ The verbs (Interactions, State Machines).
    - _Grouping:_ Packages.
    - _Annotational:_ Notes.
2. **Relationships (How things connect):** Dependency, Association, Generalization, and Realization.
3. **Diagrams (Connected graphs of things and relationships):**
    - **Structure Diagrams (Static):** Class, Component, Object, Deployment, Package, Profile, Composite Structure.
    - **Behavior Diagrams (Dynamic):** Activity, Use Case, State Machine, Interaction Diagrams (Sequence, Communication, Timing, Interaction Overview).

#### System Views

UML models the system from different perspectives:

- **Use Case View:** Behavior as seen by end-users.
- **Design View:** Classes and interfaces forming the vocabulary of the solution.
- **Interaction View:** Flow of control and messages.
- **Implementation View:** Physical files and components.
- **Deployment View:** Hardware and software nodes.

---

## Module 3: Use Case Diagrams (Behavioral)

Use Case diagrams visualize the intended behavior of the system from the user's perspective, capturing informal requirements.

### Core Components

1. **System (Rectangle):** Defines the boundary of the application. Everything inside the box happens within the system.
2. **Actor (Stick Figure):** Entities (people, organizations, or other systems) that interact with the system. Primary actors (initiators) go on the left; secondary actors (reactors/service providers, like a Bank) go on the right.
3. **Use Case (Oval):** An action that accomplishes a task (e.g., `Log in`, `Transfer Funds`). Must start with a verb.

### Relationships in Use Cases

- **Association (Solid Line):** Basic interaction between an actor and a use case.
- **Include (`<<include>>` dashed arrow):** A mandatory dependency. The base use case _must_ execute the included use case to complete. (e.g., `Make Payment` includes `Verify Sufficient Funds`). The arrow points _toward_ the included use case.
- **Extend (`<<extend>>` dashed arrow):** An optional dependency. The extended behavior only happens under specific criteria. (e.g., `Log In` is extended by `Display Login Error` only if credentials fail). The arrow points _toward_ the base use case.
    - _Extension Points:_ Specific markers in a base use case where extensions can occur.
- **Generalization (Solid line with hollow triangle):** A parent-child (is-a) relationship. Can apply to Use Cases (e.g., `Make Payment` is the parent of `Pay from Savings`) or Actors (e.g., `Customer` is the parent of `New Customer` and `Returning Customer`).

### Use Case Specifications

A detailed text document backing up the oval in the diagram. It includes:

- **Name & Overview:** Meaningful title and description.
- **Actors:** Participating entities.
- **Pre-conditions:** What must be true before execution (e.g., ATM must have cash).
- **Post-conditions:** State of the system after execution (e.g., Account balance is updated).
- **Normal Flow:** Regular sequence of events.
- **Alternative/Exceptional Flows:** Handling errors (like power failures or insufficient funds).

---

## Module 4: Class Diagrams (Structural)

Class diagrams serve as the blueprint of the system, showing the static structure, attributes, methods, and object relationships.

### The Anatomy of a Class

A class is represented by a rectangle with three compartments:

1. **Name:** Top row (e.g., `Car`).
2. **Attributes:** Middle row. Represents state/data. Typed after a colon (e.g., `make: String`).
3. **Operations (Methods):** Bottom row. Represents behavior. Includes return types and parameters (e.g., `drive(speed: int): void`).

_Note on Abstract Classes:_ If a class or method cannot be instantiated directly, its name is written in _italics_.

### Visibility (Encapsulation)

Defines the access level of attributes and methods:

- `+` **Public:** Accessible from anywhere.
- `-` **Private:** Accessible only within the class.
- `#` **Protected:** Accessible within the class and its subclasses.
- `~` **Package:** Accessible within the same package.

### Relationships Between Classes

1. **Association (Solid Line):** A "uses-a" relationship. Can be Unidirectional (one class knows about the other, denoted by an arrow) or Bidirectional (both know each other). Includes **Navigability** (arrows) and **Role Names** (labels at the ends of the line).
2. **Aggregation (Hollow Diamond):** A weak "has-a" relationship. The part can exist independently of the whole (e.g., a `MovieTheater` and `Movie`).
3. **Composition (Filled Diamond):** A strong "has-a" relationship. The part cannot exist without the whole; if the whole is destroyed, so is the part (e.g., `House` and `Room`).
4. **Inheritance/Generalization (Hollow Triangle):** An "is-a" relationship. A subclass inherits from a superclass (e.g., `Dog` inherits from `Animal`).
5. **Realization (Dashed line with hollow triangle):** A class implements an `<<interface>>`.
6. **Dependency (Dashed Arrow):** A temporary "uses" relationship. Changes in the supplier affect the client (e.g., `Customer` uses an `Order` object as a parameter in a method).

### Multiplicity (Cardinality)

Indicates how many instances of one class link to another.

- `1` (Exactly one)
- `0..1` (Zero or one)
- `*` or `0..*` (Zero or many)
- `1..*` (One or many)

### CRC Cards

A brainstorming tool used to transition use cases into class diagrams. Written on index cards with three partitions:

1. **Class:** Top (Name of the object).
2. **Responsibility:** Left (What it stores and what it does).
3. **Collaboration:** Right (Which other classes it must interact with to fulfill its responsibilities).

---

## Module 5: Component & Deployment Diagrams (Structural)

### Component Diagrams

These depict how physical, replaceable modules of a system wire together (Component-Based Development).

- **Component (Rectangle with two tabs):** A modular, executable piece of a system hiding implementation details.
- **Interfaces:** Components interact via Provided interfaces (Lollipop symbol) and Required interfaces (Socket symbol).
- **Ports (Square on the boundary):** Groups a cohesive set of interfaces, acting as a window to the component's internal classes.
- **Connectors:**
    - _Assembly Connector:_ Bridges one component's required interface to another's provided interface.
    - _Delegation Connector:_ Links a component's external port to its internal realizing classes.
- **Internal vs External Views:** An external (black-box) view just shows the component and interfaces. An internal (white-box) view nests the realizing classes inside the component shape.

### Deployment Diagrams

These map the software onto the physical hardware.

- **Nodes (3D Boxes):** Represent physical hardware (Devices, like an Application Server) or software execution environments (like an OS or Apache Tomcat).
- **Artifacts (Rectangle with folded corner):** The actual physical files produced by software (e.g., `portfolio.war`, source files, DLLs, databases).
- **Communication Associations (Solid Lines):** Represent communication paths between nodes (e.g., `TCP/IP`).
- **Deployment Specifications:** Configuration files (like `ejb-jar.xml`) dictating how an artifact is deployed.

---

## Module 6: Behavioral Modeling (Activity, Sequence, and State)

### 1. Activity Diagrams

Advanced flowcharts modeling the step-by-step logic, workflows, or business processes.

- **Action Node (Rounded rectangle):** A specific step in the flow.
- **Initial Node (Solid circle):** Where the flow begins.
- **Final Node (Solid circle with a ring):** Where the flow ends.
- **Decision / Merge Node (Diamond):** Where flows split based on a condition, or where alternate paths merge back.
- **Guards (`[condition]`):** Text conditions on transitions that must be true to proceed.
- **Fork / Join (Thick black bars):** A _Fork_ splits a single flow into parallel, concurrent activities. A _Join_ synchronizes parallel activities back into a single flow.
- **Swimlanes:** Columns that partition activities based on exactly _who_ (department, system, or person) is responsible for that step.

### 2. Sequence Diagrams

Models how objects interact _over time_ via messages to accomplish a specific use case. Focuses on time-order.

- **Object & Lifeline:** Objects (Rectangles at the top) have a dashed vertical line descending from them representing the passage of time.
- **Activation Box:** A thin rectangle on the lifeline showing the period the object is actively executing a task.
- **Messages:**
    - _Synchronous (Solid line, solid arrow):_ Sender waits for a response.
    - _Asynchronous (Solid line, lined arrow):_ Sender does not wait for a response.
    - _Reply/Return (Dashed line, lined arrow):_ Response to a previous call.
    - _Create (Dashed line with `<<create>>`):_ Instantiates a new object.
    - _Delete (Solid line ending in an `X`):_ Destroys an object.
    - _Self (U-shaped arrow):_ An object calls a method on itself.
    - _Found (Arrow originating from a solid dot):_ Message from an unknown source outside the system.
    - _Lost (Arrow pointing to a solid dot):_ Message sent to an unknown recipient.

### 3. State Machine Diagrams

Used for modeling the dynamic, event-ordered behavior of a single, highly reactive object (e.g., a Vending Machine or ATM). Focuses on how the object's state changes based on inputs.

- **State (Rounded Rectangle):** A condition during an object's life (e.g., `Idle`, `Collecting Money`).
- **Event:** A significant occurrence that triggers a transition (e.g., `cardInserted`).
- **Transition (Solid arrow):** Movement from one state to another, labeled with `Event [Guard] / Action`.
- **Action:** An atomic computation (e.g., updating a balance). Activity is an ongoing execution within the state.
- **Advanced Features:**
    - _Composite States & Substates:_ Complex states can be nested. E.g., a car's `Forward` state contains nested `First`, `Second`, and `Third` gear substates.
    - _Concurrency:_ Objects can have orthogonal, parallel state machines running simultaneously (e.g., a car's Ignition state machine runs concurrently with its Brake state machine).
    - _Signal Generalization:_ Signals can be organized hierarchically. E.g., an `Alphanumeric` keyboard press inherits from a general `UserInput` signal.

---

This notebook provides an exhaustive mapping of every concept detailed in your document. **To ensure you are fully comfortable applying this, would you like to review a specific practical example together, such as mapping out the classes for an ATM system?**