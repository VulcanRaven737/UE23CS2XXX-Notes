# ‚òÅÔ∏è Cloud Computing ‚Äî Complete Study Notebook (Part 2)

### Lectures 6‚Äì10 | Dr. Prafullata Kiran Auradkar | Dept. of CSE

---

> **How to use this notebook:** Every major topic is explained in depth, followed by a comprehensive **Q&A bank**. Work through Q&A after each section before moving on. This notebook picks up directly from Part 1.

---

# üìö TABLE OF CONTENTS

1. [Distributed System Models](https://claude.ai/chat/510a6852-187a-41e2-b7d2-f1b0319c5753#1-distributed-system-models)
    - Architectural Models (P2P, Client-Server, 3-Tier, N-Tier)
    - Interaction Models (Synchronous & Asynchronous)
    - Fault Models (Fault Types, Omission, Arbitrary, Timing)
2. [Cloud Architecture](https://claude.ai/chat/510a6852-187a-41e2-b7d2-f1b0319c5753#2-cloud-architecture)
    - Front-end, Back-end, Network
    - Back-end Components in Detail
    - Cloud Platform Design Goals
    - Market-Oriented Cloud Architecture
3. [IaaS ‚Äî Infrastructure as a Service (Deep Dive)](https://claude.ai/chat/510a6852-187a-41e2-b7d2-f1b0319c5753#3-iaas--infrastructure-as-a-service-deep-dive)
    - Programming Models (Standalone vs Virtual vs IaaS)
    - IaaS Infrastructure: Compute, Storage, Network
    - VM Creation, Block Storage, Object Storage, SDN
    - When to Use IaaS, Advantages, Limitations
4. [PaaS ‚Äî Platform as a Service (Deep Dive)](https://claude.ai/chat/510a6852-187a-41e2-b7d2-f1b0319c5753#4-paas--platform-as-a-service-deep-dive)
    - PaaS Programming Model
    - PaaS Advantages (Complete List)
    - PaaS Limitations and Concerns
    - Case Study: Google Colab as PaaS
5. [REST and Web Services](https://claude.ai/chat/510a6852-187a-41e2-b7d2-f1b0319c5753#5-rest-and-web-services)
    - Service Oriented Architecture (SOA)
    - REST: Definition, Principles, Operations
    - Safe & Idempotent Operations
    - Stateless Interactions, Representations, Self-Descriptive Messages
    - Web Services & SOAP
    - SOAP vs REST

---

# 1. Distributed System Models

## üìñ Overview

Cloud and distributed computing systems are built over large numbers of **autonomous computer nodes** interconnected by SANs (Storage Area Networks), LANs (Local Area Networks), or WANs (Wide Area Networks) in a **hierarchical manner**.

Depending on the needs of an application, the system components of a cloud infrastructure can be structured according to **three categories of Distributed System Models:**

1. **Architectural Models** ‚Äî _How_ components are placed and how responsibilities are distributed.
2. **Interaction Models** ‚Äî _How_ components communicate and handle time.
3. **Fault Models** ‚Äî _What_ can go wrong and how systems respond.

---

## üèóÔ∏è 1A. Architectural Models

Architectural models describe **how** the components of a distributed system are placed across multiple machines and how their responsibilities are distributed.

There are two sub-categories:

### System Architecture

Describes the placement of components across machines.

- **Examples:** P2P Model, Client-Server Model

### Software Architecture

Describes the logical organization of software components and their interactions.

- **Examples:** 3-Tier Architecture, N-Tier Architecture

---

### üì° Peer-to-Peer (P2P) Architecture

In a P2P network, **every node (peer) acts as both a client and a server**.

**Key characteristics:**

- **No central coordination** and no central database needed.
- **No master-slave relationship** among peers.
- Peers **autonomously join or leave** the network.
- **Self-organizing** nodes ‚Äî no peer has a global view of the entire system.
- **Distributed control** ‚Äî processing and communication loads are spread across many computers.
- **No single point of failure** ‚Äî the system functions even when some nodes fail.

**Advantages:**

- Most general and flexible model.
- Highly resilient ‚Äî no single point of failure.

**Disadvantages:**

- **Securing the overall system is more challenging** ‚Äî each peer has its own data; there is no central point to enforce security.
- Harder to manage at scale.

**Real-world examples:** BitTorrent (file sharing), Blockchain networks, early Napster.

---

### üñ•Ô∏è Client-Server Architecture

The system is structured where **servers** (dedicated machines performing a service) offer services to **clients** (machines that request those services).

**Key characteristics:**

- Based on a **simple request/reply protocol**.
- Implemented using **send/receive primitives** or **Remote Procedure Calls (RPC)**.
- Workflow: Client sends request ‚Üí Server does work ‚Üí Server returns result or error code.
- **Distributes functionality** across different machines.

**How communication works:**

- Client sends a request message.
- Server processes the request.
- Server sends back a response (or an error code if it cannot fulfill the request).

**Variations:**

1. **Three-Tier Architecture** ‚Äî Client intelligence is moved to a **middle tier** so that stateless clients can be used. This simplifies application deployment. Most web applications use 3-tier.
    
    - **Tier 1:** Client (browser/app)
    - **Tier 2:** Application/Business Logic Server (middleware)
    - **Tier 3:** Database Server
2. **N-Tier Architecture** ‚Äî Web applications that further forward requests to other enterprise services. The type most responsible for the success of **application servers**. Allows maximum modularity and scalability.
    

---

## ‚è±Ô∏è 1B. Interaction Models

Interaction models deal with **how distributed systems handle time** ‚Äî time limits on process execution, message delivery, and clock synchronization.

> **Clock Drift:** A clock that does not run at exactly the same rate as a reference clock (like NTP ‚Äî Network Time Protocol). After some time, the clock gradually "drifts apart" from others.

---

### üîÑ Synchronous Distributed System

A system where **strict time bounds** are placed on all communication and execution.

**Features:**

1. Systems share a **common clock** (same or synchronized clocks with known offsets/bounds).
2. **Lower and upper bounds** on process execution time can be set.
3. Messages are guaranteed to be received **within a known, bounded time**.
4. **Ordered message delivery** ‚Äî messages arrive in the order they were sent.
5. All processes produce output at the **same time** given the same input.
6. Allows making **assumptions about time and order of events**.

**Consequences:**

1. Requires a **global physical time** ‚Äî all nodes must be synchronized.
2. Only suitable for **hard real-time applications** (e.g., flight control systems, pacemakers).
3. **Safe to use timeouts** to detect failures ‚Äî if no response arrives within the known time bound, the process is declared failed.
4. **Not very practical** for most internet-scale systems due to synchronization complexity.

---

### üîÄ Asynchronous Distributed System

A system with **no timing guarantees** ‚Äî the model used by most real-world distributed systems including the Internet.

**Features:**

1. **Clocks may not be accurate** and can be out of sync.
2. **No bound on process/machine execution time** ‚Äî you cannot assume anything about processing speed.
3. **No bound on message transmission delays** ‚Äî messages can be delayed for arbitrary amounts of time.
4. **No constraints on time or ordering** of events.
5. Each computer processes **independently** of others.
6. **Most suitable for real-world scenarios**.

**Consequences:**

1. **No global physical time** ‚Äî reasoning must be done in terms of **logical time** (e.g., Lamport clocks, vector clocks).
2. Timing is **unpredictable**.
3. **Cannot use timeouts** to diagnose failures ‚Äî a slow response might just be delayed, not a failure.
4. Uses mechanisms like **queues** for asynchronous communication.
5. Algorithms must be designed to **tolerate various kinds of failures**.

---

### üìä Synchronous vs. Asynchronous Comparison

|Feature|Synchronous|Asynchronous|
|---|---|---|
|**Clock**|Shared / synchronized|Not synchronized|
|**Execution time bounds**|Known upper and lower bounds|No bounds|
|**Message delay bounds**|Bounded, known|Unbounded, arbitrary|
|**Message ordering**|Guaranteed|Not guaranteed|
|**Timeout-based failure detection**|Safe to use|Cannot use|
|**Global physical time**|Exists|Does not exist; use logical time|
|**Use case**|Hard real-time systems|Internet, most real-world systems|
|**Practicality**|Limited, complex|Most common model|

---

## ‚ö†Ô∏è 1C. Fault Models

### The Fault ‚Üí Error ‚Üí Failure Chain

> **Fault** (cause) ‚Üí **Error** (incorrect state) ‚Üí **Failure** (system cannot meet its promises)

- A **fault** is the root cause (e.g., a hardware defect or a software bug).
- An **error** is the incorrect system state caused by the fault.
- A **failure** is when the system cannot deliver its promised service.

Faults can occur in both **processes** and **communication channels**, due to both **software and hardware** causes.

---

### üï∞Ô∏è Types of Faults by Duration

|Fault Type|Description|Why it Matters|
|---|---|---|
|**Transient Fault**|Appears once, then disappears permanently|Easy to overlook; retrying often works|
|**Intermittent Fault**|Occurs, vanishes, reappears with no real pattern|**Worst type** ‚Äî very hard to diagnose and reproduce|
|**Permanent Fault**|Once it occurs, only replacement/repair of the faulty component restores normal function|Most straightforward to handle once detected|

---

### üî¢ Types of Faults by Nature

#### 1. Omission Faults

A process or communication channel **fails to do something it was supposed to do**.

Examples:

- A process **crashes** and stops responding (process omission).
- A message is **lost** in transit (communication omission ‚Äî e.g., packet drop).
- A server fails to **send a response** even though it received the request.

#### 2. Arbitrary Faults (Byzantine Faults)

The **worst class of faults** ‚Äî any type of error may occur, including:

- A process sending **incorrect or corrupted data** deliberately or due to bugs.
- A process **behaving maliciously** (Byzantine behavior).
- Random, unpredictable behavior that violates all assumptions.

> The term comes from the **Byzantine Generals Problem** ‚Äî how can you reach consensus when some participants might be lying or sending conflicting information?

#### 3. Timing Faults

Occur **only in synchronous systems** where there are timing constraints.

Examples:

- A process or message violates the expected **time bounds** ‚Äî response arrives too early or too late.
- Clock drift causes processes to become desynchronized.
- A real-time deadline is missed.

---

### üõ°Ô∏è Why Fault Models Matter

**Fault models** are needed to build systems with **predictable behavior in case of faults** ‚Äî in other words, to build **fault-tolerant systems**.

A fault-tolerant system will function correctly **only as long as the real faults behave as defined by the fault model**. If an unexpected fault type occurs (e.g., Byzantine faults in a system designed only for crash faults), the system may not recover correctly.

---

## ‚ùì Q&A Bank ‚Äî Distributed System Models

**Q1. What are the three categories of Distributed System Models?**

> A: (1) Architectural Models ‚Äî how components are placed and responsibilities distributed. (2) Interaction Models ‚Äî how systems handle time and communication. (3) Fault Models ‚Äî what faults can occur and their effects.

**Q2. In a P2P system, what does it mean that each node "acts as both client and server"?**

> A: Each peer can both request services from other peers (acting as a client) and provide services to other peers (acting as a server). There is no dedicated server machine.

**Q3. What is the biggest security challenge in P2P systems?**

> A: Because there is no central authority, securing the overall system is difficult ‚Äî each peer manages its own data, making centralized security enforcement impossible.

**Q4. How does the Client-Server model distribute functionality?**

> A: By separating machines into two roles ‚Äî servers that perform specific functions, and clients that request those functions ‚Äî the responsibilities are cleanly distributed between machines.

**Q5. What is the difference between 3-tier and N-tier architecture?**

> A: 3-tier moves client logic to a middle tier, creating 3 layers (client, application/business logic, database). N-tier further extends this by adding more layers to forward requests to other enterprise services, enabling maximum modularity.

**Q6. Why are most real-world distributed systems asynchronous rather than synchronous?**

> A: Because achieving true synchrony (global clock, bounded delays) across internet-scale systems is impractical. The internet has unpredictable delays, and different machines cannot be perfectly synchronized.

**Q7. What is "clock drift" and why is it a problem for distributed systems?**

> A: Clock drift is when a computer's clock gradually falls out of sync with a reference clock. In distributed systems, this can cause events to appear to happen in the wrong order, breaking time-based coordination.

**Q8. Why can't you use timeouts for failure detection in an asynchronous system?**

> A: Because there are no bounds on message delays in an asynchronous system. A slow response might just be a delayed message, not a crashed server ‚Äî you cannot distinguish between the two using time alone.

**Q9. What is the Fault ‚Üí Error ‚Üí Failure chain? Give an example.**

> A: A **fault** (e.g., a disk sector physically damaged) causes an **error** (e.g., data read incorrectly) which causes a **failure** (e.g., the database returns wrong results to a user).

**Q10. Which type of fault is the hardest to diagnose and why?**

> A: **Intermittent faults** ‚Äî because they appear and disappear with no consistent pattern, making them very hard to reproduce in testing environments.

**Q11. What is an Omission Fault? Give two examples.**

> A: A fault where something fails to happen that should have. Examples: (1) A process crashes and stops responding entirely. (2) A network packet is dropped and never arrives at the destination.

**Q12. What is an Arbitrary (Byzantine) Fault? Why is it the worst type?**

> A: A fault where any behavior may occur ‚Äî including incorrect, contradictory, or malicious behavior. It's the worst because no assumptions can be made about how the faulty component will behave.

**Q13. What is a Timing Fault and in which type of system does it occur?**

> A: A timing fault occurs only in synchronous systems when a process or message violates its time bounds (responds too early or too late). Asynchronous systems don't have timing faults because no bounds are defined.

**Q14. What is the purpose of a Fault Model?**

> A: To formally define what kinds of faults a system is designed to handle, enabling the construction of fault-tolerant systems that behave predictably when those specific faults occur.

**Q15. Compare P2P and Client-Server in terms of centralization, failure, and complexity.**

> A: P2P is decentralized, has no single point of failure, and is complex to secure. Client-Server is centralized (server side), may have single point of failure if server goes down, but is simpler to secure and manage.

---

# 2. Cloud Architecture

## üìñ What is Cloud Architecture?

**Cloud Architecture** refers to the way in which the technology components that make up a cloud environment are **engineered or combined** to leverage the power of cloud resources to solve business problems. It defines:

- The **components** of a cloud system.
- The **relationships** between those components.

---

## üèõÔ∏è Three Major Components of Cloud Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              FRONT-END (Client)                 ‚îÇ
‚îÇ   Browsers, thin/fat clients, mobile devices   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                       ‚îÇ Internet / Intranet / Intercloud
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ              BACK-END (Server)                  ‚îÇ
‚îÇ  Applications, Services, Runtime, Storage,     ‚îÇ
‚îÇ  Infrastructure, Management, Security          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

---

## üñ•Ô∏è A. Front-End (Client Infrastructure)

The **front-end** is the client-side of the cloud architecture ‚Äî the interface through which users access cloud computing platforms.

**Examples:**

- Web clients (Chrome, Firefox, Internet Explorer)
- **Thin clients** ‚Äî lightweight devices with minimal local processing; rely on the server for computation
- **Fat clients** ‚Äî full-featured devices with significant local processing ability (e.g., a full desktop PC running a cloud app)
- Tablets
- Mobile devices

The front-end's job is simply to provide a user interface and send/receive data ‚Äî all heavy processing is done on the back-end.

---

## ‚öôÔ∏è B. Back-End (Service Provider Infrastructure)

The **back-end** is managed by the **cloud service provider** and contains all components needed to provide cloud services. It includes **7 key components:**

### 1. Application

The application offered to the client. This can either be:

- **Software** (like a SaaS application)
- **A platform** (like a PaaS development environment)

### 2. Service

A piece of software that **manages the application needs** and determines which type of cloud service (IaaS, PaaS, or SaaS) is appropriate and should be accessed. Think of it as the service broker layer.

### 3. Runtime Cloud

Provides the **execution and runtime environment** to the Virtual Machine, dependent on the service model. For example, a Java runtime for JVM-based applications, or a Python interpreter for Python apps.

### 4. Storage

One of the **most critical components** of cloud computing. Provides:

- Huge amounts of storage capacity.
- Multiple types: block storage, object storage, relational databases.
- Manages and stores data for cloud-hosted applications.

### 5. Infrastructure

The physical and virtual hardware layer:

- Physical servers, storage devices, network devices
- **Virtualization software** (hypervisors)
- Network infrastructure Everything needed to physically support the cloud computing model.

### 6. Management

Handles **coordination between all back-end components**. Ensures:

- Applications, services, storage, and infrastructure work together.
- Resource allocation is managed.
- Monitoring and provisioning are handled.

### 7. Security

Implements **security mechanisms** to protect:

- Cloud resources
- Systems and files
- Infrastructure
- End-user data Includes encryption, firewalls, identity management, access control.

---

## üåê C. Network (Internet / Intranet / Intercloud)

The **network** acts as the **medium or bridge** between the front-end and back-end. It establishes interaction and communication between the two.

- **Internet:** For public cloud access.
- **Intranet:** For private cloud access within an organization.
- **Intercloud:** For cloud-to-cloud communication (e.g., hybrid cloud environments where private and public clouds communicate).

---

## üéØ Cloud Platform Design Goals

When designing and architecting a cloud platform, the following goals are targeted:

|Goal|Description|
|---|---|
|**Scalability**|Scale up, scale out, scale down as needed|
|**Efficiency**|Do tasks quickly with minimal resource utilization; bring up services rapidly across the stack|
|**Reliability & Availability**|Ensure the system stays up and functional even during failures|
|**Simplified User Experience**|Abstract complexity so users can focus on their tasks, not infrastructure|

These goals are typically enabled by architectural techniques like:

- **Clustering** ‚Äî using multiple servers for redundancy and load distribution
- **Virtualization (Hypervisor)** ‚Äî abstracting hardware into virtual resources
- **Replication** ‚Äî copying data across multiple locations
- **Elasticity** ‚Äî automatic resource scaling
- **Simple deployment and scheduling approaches**

---

## üìä Generic Cloud Architecture

A generic cloud platform is built with:

- A **virtual cluster** of VMs, storage, and networking resources.
- Operated by **data-center servers** run by the provider.
- Security layer wrapping the entire infrastructure.

**Amazon AWS VPC (Virtual Private Cloud)** is a real-world example where:

- You define your own virtual network inside the AWS cloud.
- Control IP ranges, subnets, routing, gateways.
- VMs (EC2 instances) exist inside this virtual network.

---

## üè™ Market-Oriented Cloud Architecture

As consumers increasingly rely on cloud providers, they require **specific QoS (Quality of Service) levels** to maintain their operations.

A **market-oriented resource management system** regulates **supply and demand** of cloud resources to achieve equilibrium ‚Äî essentially treating cloud resources like a marketplace.

### Key Mechanisms:

|Component|Role|
|---|---|
|**Request Examiner**|Ensures no overloading or over-provisioning; checks if service requests can be fulfilled|
|**Pricing Mechanism**|Decides how service requests are charged; economic incentives proportional to QoS|
|**VM Monitor**|Tracks availability of VMs and their resource entitlements|
|**Dispatcher**|Starts execution of accepted service requests on allocated VMs|
|**Service Request Monitor**|Tracks the execution progress of service requests|

**Key principle:** Multiple VMs can be started and stopped on demand on a single physical machine, providing maximum flexibility. Resources are allocated and priced based on QoS requirements.

---

## ‚ùì Q&A Bank ‚Äî Cloud Architecture

**Q1. What does "Cloud Architecture" mean?**

> A: The way in which technology components of a cloud environment are engineered and combined to leverage cloud resources, including defining the components and their relationships.

**Q2. What are the three major components of cloud architecture?**

> A: (1) Front-end (client infrastructure), (2) Back-end (server/service provider infrastructure), (3) Network (Internet/Intranet/Intercloud connecting the two).

**Q3. What is the difference between a thin client and a fat client?**

> A: A thin client is a lightweight device with minimal local processing that relies heavily on the server. A fat client is a full-featured device (like a PC) that can do significant local processing but also connects to cloud services.

**Q4. List the 7 components of the back-end in cloud architecture.**

> A: (1) Application, (2) Service, (3) Runtime Cloud, (4) Storage, (5) Infrastructure, (6) Management, (7) Security.

**Q5. What is the role of the "Runtime Cloud" component in the back-end?**

> A: It provides the execution and runtime environment to the Virtual Machine, tailored to the service model ‚Äî e.g., the language runtime, OS environment, or container runtime needed for the application.

**Q6. What is the Intercloud, and when is it used?**

> A: The Intercloud is a network connecting multiple cloud systems together. It's used in hybrid cloud environments where a private cloud and a public cloud need to communicate and share workloads.

**Q7. What are the four design goals of a cloud platform?**

> A: Scalability, Efficiency, Reliability & Availability, and Simplified User Experience.

**Q8. What is a Market-Oriented Cloud Architecture?**

> A: An architecture that regulates supply and demand of cloud resources like a marketplace, allocating resources based on QoS requirements and economic incentives.

**Q9. What does the "Dispatcher" do in a Market-Oriented Cloud Architecture?**

> A: It starts the execution of accepted service requests on allocated VMs.

**Q10. What does the "Request Examiner" do?**

> A: It ensures that resources are not overloaded or over-provisioned by checking whether incoming service requests can be fulfilled within resource constraints.

**Q11. Why is "Management" a critical back-end component?**

> A: Because a cloud back-end has many interdependent components (applications, services, storage, infrastructure). Management coordinates all of these, ensuring they work together seamlessly for reliable service delivery.

**Q12. How do clustering and replication contribute to cloud architecture goals?**

> A: Clustering contributes to scalability and availability by distributing load across multiple servers. Replication contributes to availability and reliability by keeping copies of data at multiple locations, so one failure doesn't cause data loss.

---

# 3. IaaS ‚Äî Infrastructure as a Service (Deep Dive)

## üìñ What is the Programming Model Concept?

A **programming model** is an execution model linked to an API or a particular pattern of code. There are actually **two execution models** in any program:

1. **The execution model of the base programming language** (e.g., C executes instructions one by one sequentially; Python has its interpreter model).
2. **The execution model of the programming model** (how the cloud environment executes and manages programs).

### On a Standalone System:

A simple C program running locally:

- Accesses CPU, memory, disk, and network **directly through the OS**.
- Resources are local and guaranteed to be available.
- The OS mediates all hardware access.

### On a Cloud (IaaS/PaaS/SaaS):

- **The language execution model doesn't change** (C is still C).
- BUT the **environment** is different ‚Äî CPU, memory, storage, and network are **not local**.
- They are **virtual resources** allocated from a pool.
- The programming model must **factor in** this virtualized environment.
- Depending on the service model, the platforms and frameworks cannot be assumed to be the same as on a local machine.

---

## üèóÔ∏è IaaS Formal Definition

> _"The capability provided to the consumer is to provision processing, storage, networks, and other fundamental computing resources where the consumer is able to deploy and run arbitrary software, which can include operating systems and applications."_

- The consumer does **not** manage or control the underlying cloud infrastructure.
- BUT has **control over** operating systems, storage, deployed applications, and possibly limited networking (e.g., host firewalls).
- The **IaaS provider controls** the actual hardware; the cloud user **requests allocation of virtual resources**.
- Enables end users to **scale and shrink** resources on an as-needed basis.
- Reduces need for high upfront capital expenditures (especially important for "spiky" workloads ‚Äî workloads with unpredictable peaks).

---

## üíª IaaS Infrastructure Components

IaaS is made up of a collection of **physical and virtualized resources** ‚Äî the basic building blocks for running applications in the cloud.

### 1. Physical Data Centers

IaaS providers manage **large data centers worldwide** containing physical machines with various **layers of abstraction** on top. End users access these resources via the internet.

### 2. Compute: Virtual Machines (VMs) and Containers

The provider provisions compute resources using **virtualization**:

#### Virtual Machines (VMs)

- Each VM **"looks like" an actual physical machine** to the software running on it.
- Can have its **own OS and software stack**.
- **VMs may belong to different users** ‚Äî multi-tenancy.
- Each VM is **isolated** from other VMs on the same physical host.
- Achieved via the **Hypervisor** (studied later).

#### Containers

- Use the **physical server's operating system** (no guest OS needed).
- Are essentially a **sandboxed process** on the host.
- **More lightweight** than VMs ‚Äî less overhead, faster to start.
- Examples: Docker containers.

|Feature|VM|Container|
|---|---|---|
|**OS**|Has its own complete OS|Shares host OS|
|**Weight**|Heavier|Lighter|
|**Isolation**|Strong (hardware level)|Process-level|
|**Startup time**|Slower (minutes)|Faster (seconds)|
|**Use case**|Full OS customization|Microservices, fast deployment|

### 3. Storage

Three main types of cloud storage:

#### Block Storage

- A way of **sharing and pooling physical disks** into virtual disks.
- **Example:** A 256 GB virtual disk can be built from 2 √ó 128 GB physical disks from different servers.
- Each virtual disk **"looks like" an actual physical disk** to the software.
- Can create files, use for paging/swapping, just like a real disk.
- Virtual disks may belong to different users; each is **isolated** from others.

**Key question:** _Can a virtual disk be bigger than any single physical disk?_ Yes ‚Äî it can span multiple physical disks.

#### Object Storage

The most common mode of storage in the cloud. Key advantages:

- **Highly distributed** (and thus resilient) ‚Äî data is spread across many nodes.
- Leverages **commodity hardware** ‚Äî cheap, standard disks.
- Data can be accessed easily over **HTTP**.
- **Essentially limitless scale** ‚Äî and performance scales linearly as the cluster grows.
- Examples: Amazon S3, Google Cloud Storage.

#### Relational / NoSQL Databases

- Managed database services where the provider handles installation, patching, backups.
- User just uses the database via APIs.

### 4. Networking (Software Defined Networking ‚Äî SDN)

Cloud networking is a form of **Software Defined Networking (SDN)** where traditional networking hardware (routers, switches) is made available **programmatically** through APIs.

**Components:**

- **Virtual Network Adapter (V):** Each VM has one or more virtual network adapters with their own **IP addresses and DNS names** ‚Äî just like physical network cards. Completely in software.
- **Virtual Network Switch (VS):** A completely software-based switch connecting virtual adapters.
- **Virtual Port (VP):** A virtual port connecting to the virtual switch. Invisible to the external network ‚Äî has only a MAC address, no IP.
- **Physical Network Adapter (N):** The actual physical NIC of the server, connecting to the real network.

This entire networking stack is **software** ‚Äî flexible, programmable, and instantly reconfigurable.

---

## üîß How a VM is Created in IaaS

When a user requests a VM, the following happens:

1. **User specifies:**
    
    - VM configuration (e.g., amount of memory, number of vCPUs)
    - Software to install (OS type, applications)
2. **Cloud software:**
    
    - Creates the actual VM.
    - Creates virtual disk(s) needed.
    - Copies OS and application binaries to the boot disk.
    - Boots the OS.
    - Sets up virtual network adapters and connects to virtual network.

The VM is then running and available to the user, accessible via a web server or SSH.

---

## üìä Old Model vs. New Model with IaaS

|Aspect|Old Model (On-Premises)|New Model (IaaS)|
|---|---|---|
|**Hardware purchase**|Large upfront investment|Pay per use; no purchase|
|**Provisioning time**|Weeks to months|Minutes|
|**Scaling**|Manual, physical hardware needed|Automated, virtual|
|**Underutilized capacity**|You own it and pay for it|Only pay for what you use|
|**Optimization**|Coupled (hardware to software)|Decoupled (virtual layer)|

---

## ‚úÖ IaaS Advantages (Detailed)

|Advantage|Explanation|
|---|---|
|**Flexible**|Most flexible cloud model ‚Äî complete control over the software stack|
|**Control**|Clients retain complete control of their infrastructure|
|**Pay-as-you-Go**|No upfront CapEx; pay only for what you use|
|**Speed**|Provision resources in minutes instead of weeks|
|**Availability**|Multi-zone regions provide higher availability than traditional approaches|
|**Scale**|Seemingly limitless capacity; scale automatically or manually|
|**Latency & Performance**|Geographic footprint lets you place apps close to users|

---

## üéØ When to Use IaaS

|Scenario|Why IaaS is Ideal|
|---|---|
|**Startups and small companies**|Avoid spending on hardware; get infrastructure instantly|
|**Larger companies wanting control**|Retain full control while paying only for what they use|
|**Companies experiencing rapid growth**|Easily swap hardware/software as needs evolve|
|**Website hosting**|Less expensive than traditional web hosting|
|**Storage, backup, and recovery**|Avoid storage management complexity; handle unpredictable demand|
|**High-Performance Computing (HPC)**|Access supercomputer-level resources on demand|
|**Big Data Analysis**|Economically provision massive processing power for data mining|
|**New/uncertain application demands**|IaaS provides flexibility when requirements are unclear|

---

## ‚ö†Ô∏è IaaS Limitations and Concerns

1. **Security:** Even though the customer controls the apps, data, and OS, security threats can come from the **host infrastructure itself or other VMs**. Insider threats or system vulnerabilities may expose communication between host and VMs.
    
2. **Multi-tenant security:** Hardware is dynamically shared. The vendor must ensure:
    
    - Previous customers' data is not accessible to new customers (in storage).
    - VMs are adequately isolated from each other.
3. **Internal resources and training:** Staff may need training to manage virtualized infrastructure. Monitoring and managing cloud resources requires specialized skills.
    

---

## üè¢ IaaS Providers

|Provider|IaaS Product|
|---|---|
|Amazon Web Services|Amazon EC2 (Elastic Compute Cloud)|
|Microsoft Azure|Azure Virtual Machines|
|Google Cloud|Google Compute Engine|
|IBM Cloud|IBM Cloud Private|
|Digital Ocean|Digital Ocean Droplets|

---

## ‚ùì Q&A Bank ‚Äî IaaS Deep Dive

**Q1. What are the two execution models present in any cloud-hosted program?**

> A: (1) The language execution model (e.g., how C runs sequentially), and (2) The programming model execution (how the cloud platform manages and provides the environment for the program).

**Q2. What does a user control in IaaS, and what does the provider control?**

> A: User controls: OS, storage, deployed applications, possibly some networking. Provider controls: physical hardware, virtualization layer, physical network infrastructure.

**Q3. What is a "spiky workload" and how does IaaS address it?**

> A: A spiky workload has unpredictable peaks (e.g., a retail site during holidays). IaaS lets you scale up resources for the peak and scale down afterward, paying only for what you used, rather than permanently buying hardware for peak capacity.

**Q4. What is the fundamental difference between a VM and a Container?**

> A: A VM has its own complete OS (heavier, more isolated). A Container shares the host OS and is just a sandboxed process (lighter, faster to start, less isolated).

**Q5. What is Block Storage and how can a virtual disk be larger than a physical disk?**

> A: Block storage pools physical disks into virtual disks. A virtual disk can span multiple physical disks ‚Äî e.g., a 256 GB virtual disk can be built from two 128 GB physical disks.

**Q6. Why is Object Storage the most common mode in cloud computing?**

> A: Because it is highly distributed (resilient), uses cheap commodity hardware, is accessible over HTTP, and scales linearly ‚Äî both in capacity (essentially limitless) and performance.

**Q7. What is Software Defined Networking (SDN)?**

> A: SDN is where traditional networking hardware (routers, switches) is replaced by software and made available programmatically through APIs, enabling flexible, instant network reconfiguration.

**Q8. List the steps that happen when a VM is created in IaaS.**

> A: (1) User specifies VM configuration and software. (2) Cloud creates the VM. (3) Virtual disks are created. (4) OS and app binaries are copied to boot disk. (5) OS boots. (6) Virtual network is set up.

**Q9. What is a Virtual Network Adapter and how does it compare to a physical one?**

> A: A virtual network adapter is completely in software but behaves exactly like a physical network adapter ‚Äî it has an IP address and DNS name. The VM's software cannot tell it is not real hardware.

**Q10. Who would benefit most from IaaS ‚Äî a startup or an enterprise, and why?**

> A: Both but differently. A startup benefits from zero upfront cost ‚Äî it gets enterprise-level infrastructure without buying hardware. An enterprise benefits from retaining full control over their software stack while only paying for what they use.

**Q11. Why is IaaS the "most flexible" service model?**

> A: Because it gives the user complete control over the entire software stack ‚Äî OS, middleware, runtime, applications ‚Äî unlike PaaS (which constrains you to their middleware) or SaaS (where you only configure the app).

**Q12. What is the multi-tenant security problem in IaaS?**

> A: Multiple users share the same physical hardware. If VMs are not properly isolated, one user could potentially access another user's data, especially in storage (data from a previous customer not cleared properly).

---

# 4. PaaS ‚Äî Platform as a Service (Deep Dive)

## üìñ What is PaaS?

PaaS is a **complete development and deployment environment in the cloud** with resources that enable you to deliver everything from simple cloud-based apps to sophisticated enterprise applications.

> PaaS supports a cloud application across its **complete lifecycle: building ‚Üí testing ‚Üí deploying ‚Üí managing ‚Üí updating** ‚Äî all within the same integrated environment.

**What it includes (beyond IaaS):**

- Abstracted infrastructure (servers, storage, networking)
- **Middleware** (application servers, runtime environments)
- **Development tools** (code editors, debuggers, version control integration)
- **Business intelligence (BI) services**
- **Database management systems**
- Analytics tools

The hardware and mapping to virtual resources is controlled by the **PaaS provider**. The user configures and builds on top of the middleware.

---

## üîß PaaS Programming Model ‚Äî How It Works

### The Problem (With IaaS for Developers)

Consider building a **photo-sharing app** with:

- User uploads photo
- App recognizes faces
- App stores photos and face data in database

**In an IaaS model**, a developer must manually:

1. Start a VM
2. Connect a block storage device
3. Install Web Server
4. Install App Server
5. Install Database
6. Upload application
7. Run Application

This is **a lot of infrastructure work** for a developer.

### The Solution: PaaS Programming Model

In a PaaS model (e.g., Windows Azure):

1. **Application is uploaded** ‚Äî that's it for the developer in terms of infrastructure.
2. The application is made up of **components/sections**, each specifying its environment:
    - **Web Roles** ‚Äî front-end type tasks (handling HTTP requests from users)
    - **Worker Roles** ‚Äî background tasks (face recognition processing, database writes)
3. The developer **specifies initial number of components** and **scale up/scale down policies**.
4. The **PaaS Layer then automatically:**
    - Deploys the application
    - Allocates resources (creates VMs and containers automatically)
    - Connects to services
    - **Automatically scales up or down** based on defined policies

### What the Cloud Controller Does in PaaS:

- Automatically creates VMs and containers
- Deploys applications
- Connects to services
- Automatically scales up or down

### Storage Services Available in PaaS:

- **Object storage** ‚Äî unstructured files
- **NoSQL** ‚Äî flexible schema databases
- **Relational** ‚Äî traditional SQL databases
- **Block storage** ‚Äî raw disk access

Applications store their state in these Storage Services, which:

- **Simplifies scaling** (stateless app can be replicated freely)
- **Makes recovery from failure easier** (state is in managed storage, not in the app instance)

---

## ‚úÖ PaaS Advantages (Complete List)

1. **Faster, easier development setup** ‚Äî No need to build or maintain a development platform. Tap into the PaaS provider's resources and begin developing immediately.
    
2. **Wider range of resources** ‚Äî Access to more OS options, middleware, databases, libraries, and tools than you could practically maintain on-premises. Test new tools **without investment risk**.
    
3. **Develop for multiple platforms more easily** ‚Äî Including mobile. Cross-platform apps are quicker and easier to build when the PaaS provides multi-platform tooling.
    
4. **Easy, cost-effective scalability** ‚Äî Scale on-demand by purchasing just the additional capacity needed, rather than over-buying hardware.
    
5. **Support geographically distributed development teams** ‚Äî Teams in different locations share the same cloud development environment.
    
6. **Efficiently manage the application lifecycle** ‚Äî Build, test, deploy, manage, and update all within the same integrated environment.
    
7. **Lower costs** ‚Äî No infrastructure to build means lower upfront costs. Most PaaS providers charge based on usage.
    
8. **Development framework** ‚Äî Built-in software components with cloud features (scalability, high availability, multi-tenancy) already included ‚Äî reducing the amount of custom code developers must write.
    
9. **Analytics/Business Intelligence** ‚Äî Tools provided as a service allow mining data for insights, predictions, and forecasting.
    

---

## ‚ö†Ô∏è PaaS Limitations and Concerns

1. **Reduced operational control** ‚Äî PaaS limits what operators can do with the infrastructure. The provider manages the underlying platform, reducing flexibility for specialized configurations.
    
2. **Vendor lock-in** ‚Äî Apps built for one PaaS vendor cannot easily be moved to another. If the vendor changes pricing or discontinues a service, migration is costly.
    
3. **Runtime issues** ‚Äî PaaS may not support every language or framework. Specific framework versions may not be available or may not perform optimally. You may not be able to create custom dependencies.
    
4. **Data security** ‚Äî Application data resides on third-party servers. Security options may be limited ‚Äî customers may not be able to enforce specific hosting policies.
    
5. **Integration complexity** ‚Äî Connecting cloud-hosted PaaS data with on-premises data centers is complex. Legacy IT systems not designed for the cloud may not integrate smoothly.
    
6. **Customization of legacy systems** ‚Äî PaaS is not a plug-and-play solution for legacy applications. Significant customization may be needed, potentially undermining the simplicity benefits.
    

---

## üè¢ PaaS Providers

|Provider|PaaS Product|
|---|---|
|Amazon Web Services|AWS Elastic Beanstalk|
|Microsoft Azure|Azure DevOps|
|Google Cloud|Google App Engine|

---

## üì± When to Use PaaS

- **API development and management** ‚Äî Develop, run, manage, and secure APIs and microservices.
- **IoT (Internet of Things)** ‚Äî PaaS supports the broad range of environments, languages, and tools used for IoT.
- **Multiple developers collaborating** ‚Äî PaaS streamlines workflows for teams.
- **Custom application development** ‚Äî When you need tailored applications but don't want to manage infrastructure.
- **When you need vendor-supplied middleware** ‚Äî PaaS is ideal when the middleware available matches what you need.

---

## üî¨ Case Study: Google Colab as a PaaS

Google Colab is an excellent real-world example of PaaS in action.

### How Colab Demonstrates PaaS Characteristics:

|PaaS Feature|How Colab Implements It|
|---|---|
|**Cloud-Hosted Environment**|Opens a VM on Google's servers via browser ‚Äî no local installation needed|
|**Managed Runtime**|Google manages the entire execution environment (Python interpreter, TensorFlow, PyTorch, NumPy, Pandas) ‚Äî pre-installed|
|**Access to High-Performance Hardware**|Free access to GPUs and TPUs without purchasing them ‚Äî switchable via settings|
|**Interactive Interface**|Jupyter notebook format: code cells + rich text + inline visualizations|
|**Seamless Collaboration**|Notebooks saved to Google Drive; shared like Google Docs; GitHub integration|
|**Isolation & Ephemeral Sessions**|Each session runs in an isolated container. Data/environment persist only for the session; VM is recycled after|

### Why Colab is PaaS and not IaaS or SaaS:

- You **write and run code** (not just use a finished application ‚Üí not SaaS).
- You **don't manage the underlying infrastructure** (don't install Python, don't configure OS ‚Üí not IaaS).
- You **use Google's managed platform** to develop and run code ‚Üí **PaaS**.

---

## ‚ùì Q&A Bank ‚Äî PaaS Deep Dive

**Q1. What does PaaS support beyond what IaaS provides?**

> A: On top of IaaS infrastructure, PaaS adds middleware, development tools, BI services, database management systems, analytics tools, and manages the entire application lifecycle.

**Q2. What is the key difference in a developer's experience between IaaS and PaaS?**

> A: In IaaS, the developer must manually set up the entire stack (VM, web server, app server, database). In PaaS, the developer just uploads the application code and the platform handles everything else automatically.

**Q3. What are "Web Roles" and "Worker Roles" in the Windows Azure PaaS model?**

> A: Web Roles handle front-end tasks (HTTP requests from users). Worker Roles handle background processing tasks (e.g., processing uploaded images, running batch jobs).

**Q4. Why does storing application state in PaaS Storage Services simplify scaling?**

> A: If state is stored externally (in managed storage), individual app instances are stateless. Stateless instances can be freely replicated across many machines, making horizontal scaling trivial.

**Q5. What is the biggest commercial risk of using PaaS?**

> A: Vendor lock-in ‚Äî applications are built using the specific tools, languages, and APIs of one PaaS provider. If the provider changes terms or discontinues the service, migrating is very costly.

**Q6. Why can't PaaS always support every programming language or framework?**

> A: PaaS providers pre-build and manage specific runtime environments. They can only support the languages and framework versions they have explicitly built and maintain ‚Äî custom or obscure environments may not be available.

**Q7. How does PaaS reduce the amount of code developers need to write?**

> A: PaaS provides a development framework with built-in cloud features like scalability, high availability, and multi-tenancy already implemented. Developers don't need to write their own code for these concerns.

**Q8. How does Google Colab demonstrate the PaaS model?**

> A: Users open a browser and immediately get a managed Python environment with pre-installed ML libraries, GPU access, and collaboration features ‚Äî no installation, no server management. They develop (PaaS), they don't manage infrastructure (IaaS) or just use a finished app (SaaS).

**Q9. What are "Ephemeral Sessions" in Google Colab and why does this reflect PaaS?**

> A: Each Colab session runs in an isolated container that is recycled when the session ends. This reflects PaaS's characteristic that the platform manages resource lifecycle ‚Äî Google efficiently reclaims resources after use.

**Q10. What is the "application lifecycle" that PaaS manages, and why is this valuable?**

> A: Build ‚Üí Test ‚Üí Deploy ‚Üí Manage ‚Üí Update. Having all these stages in one integrated environment eliminates the need to stitch together separate tools, reducing complexity and time.

**Q11. Name three specific use cases where PaaS is especially well-suited.**

> A: (1) API development and microservices management, (2) IoT application development requiring multi-environment support, (3) Distributed teams collaborating on the same project.

**Q12. What is the "integration complexity" limitation of PaaS?**

> A: Connecting cloud-hosted PaaS data with on-premises legacy systems or other data centers is difficult because the systems may use different protocols, data formats, or security models not designed to work with each other.

---

# 5. REST and Web Services

## üìñ Service Oriented Architecture (SOA)

**SOA (Service Oriented Architecture)** is an approach to software design where services are provided to other components through a **network via communication protocols**.

**Key ideas:**

- Each service **embodies the code and data integrations required to execute a complete, discrete business function**.
- Service interfaces provide **loose coupling** ‚Äî meaning services can be called with little or no knowledge of how the integration is implemented underneath.
- Services communicate via standard protocols: **SOAP/HTTP or JSON/HTTP**.
- Services are **published** so developers can find and **reuse** them to assemble new applications.

**Two major SOA styles:**

1. **REST** (REpresentational State Transfer)
2. **SOAP-based Web Services**

---

## üåê REST ‚Äî REpresentational State Transfer

### What is REST?

REST is an **architectural style** (sometimes called a programming style) that provides a **set of rules** for building computer systems on the web, making it easier for systems to communicate with each other.

**Key points:**

- REST is **not a standard** ‚Äî it is a **design and architectural style** for large-scale distributed systems.
- REST is **not the same as HTTP** ‚Äî HTTP is a protocol that can be used in non-RESTful ways (e.g., SOAP also uses HTTP to transport data).
- An API that adheres to REST constraints is called a **RESTful API**.
- RESTful APIs typically use **HTTP methods** to access resources via **URL-encoded parameters** and transmit data using **JSON or XML**.
- REST exploits the **Web's architecture** to make distributed systems simpler, more scalable, and easier to understand.

---

## üìã REST Design Principles (The 5 Constraints)

These are the **mandatory constraints** for a system to be considered RESTful:

### 1. Client-Server Constraint (Separation of Concerns)

The client and server are **separated** ‚Äî they can evolve independently:

- The **client can change** (new UI, new platform) without the server having to change.
- The **server can change** (new database, new implementation) without breaking clients.
- Essentially: how the client sends messages and how the server responds/rejects them.

**Benefit:** Separation improves scalability (server components can be simplified) and portability of the client.

### 2. Stateless Constraint

The communication between client and server **must remain stateless between requests**.

- Each client request must **contain all information** the server needs to respond.
- The server **stores no client context between requests** (no session state on the server).
- All state must be transferred **back to the client** as part of each response.
- Session state is kept **entirely on the client**.

> This is the "S" and "T" in REST ‚Äî we are always giving the **State** **T**ransfer to the client.

**Benefit:** Statelessness means any server can handle any request ‚Üí enables load balancing and fault tolerance.

**Trade-off:** Every request must be self-contained ‚Üí more data per request ‚Üí can impact performance (addressed by caching).

### 3. Cache Constraint

To improve network efficiency, server responses must be **labeled as cacheable or non-cacheable**.

- If a response is marked **cacheable**, the client can reuse that response for later equivalent requests, without contacting the server.
- Reduces server load and network traffic for repeated identical requests.

### 4. Uniform Interface Constraint

A **uniform interface** makes the system generic, improving visibility and decoupling implementations from services.

Defined by **4 sub-constraints:**

- **a. Resource Identification** ‚Äî Resources are identified using **URIs** (Uniform Resource Identifiers), e.g., `/api/books/123`.
- **b. Manipulation of Resources through Representations** ‚Äî Clients manipulate resources by sending/receiving **representations** (JSON/XML/HTML snapshots of the resource's current state).
- **c. Self-Descriptive Messages** ‚Äî Each message contains enough information to describe **how to process it** (e.g., Content-Type headers tell the client how to parse the body).
- **d. Hypermedia as the Engine of Application State (HATEOAS)** ‚Äî The API response contains **hypermedia links** to related resources and available actions, allowing clients to navigate dynamically.

### 5. Layered System Constraint

Messages between client and server can go through **a hierarchy of intermediate components** (load balancers, proxy servers, firewalls, caches).

- These intermediaries **cannot "see" the next layer** ‚Äî they only know about the layer immediately adjacent.
- The client-server interaction is **not affected** by adding or removing layers.
- All communication remains **consistent** regardless of intermediaries.

**Benefit:** Enables load balancers, security proxies, and caches to be inserted without changing client or server code.

---

## üîë Resources and URIs in REST

**Resource:** Any information that can be named ‚Äî a document, an image, a service, a person, a device.

> Example: A light in a seminar hall can be a resource with URI: `/pesu/b-block/groundfloor/seminarhall/board/light/1`

**URI (Uniform Resource Identifier):**

- Provides a **global addressing space** for resources.
- Makes resources **discoverable** and accessible.
- Can be bookmarked or shared via hyperlinks.

The RESTful web service exposes a set of resources. Clients can **only access resources using URIs** ‚Äî they request a URI and the server responds with a **representation** of the resource.

---

## üõ†Ô∏è REST Operations (CRUD Interface)

Interaction with RESTful services uses the **HTTP standard protocol**. Resources are manipulated using **4 CRUD operations**:

|HTTP Method|CRUD Operation|Action|
|---|---|---|
|**GET**|**Read**|Retrieve a specific resource or a collection of resources|
|**POST**|**Create**|Create a new resource or partially update one|
|**PUT**|**Create / Update**|Create or update a resource by full replacement|
|**DELETE**|**Delete**|Remove a resource|

**Example (Book library app):**

- `GET /books` ‚Üí Get all books
- `GET /books/123` ‚Üí Get book with ID 123
- `POST /books` ‚Üí Add a new book
- `PUT /books/123` ‚Üí Replace/update book 123
- `DELETE /books/123` ‚Üí Delete book 123

---

## ‚ö° Safe and Idempotent Operations

These are important characteristics that determine how operations can be safely retried.

**Safe Operation:** An operation that **does not modify** any resources. It only reads data.

- **Example:** `GET` is safe ‚Äî calling it 100 times changes nothing.

**Idempotent Operation:** An operation that produces the **same result** regardless of how many times it is executed.

- **Example:** `PUT /books/123` with the same data always results in the same state, whether called once or ten times.
- **Example:** `DELETE /books/123` ‚Äî after the first call, the book is deleted. Subsequent calls find no book ‚Äî same end state.

|HTTP Method|Safe?|Idempotent?|
|---|---|---|
|**GET**|‚úÖ Yes|‚úÖ Yes|
|**POST**|‚ùå No|‚ùå No|
|**PUT**|‚ùå No|‚úÖ Yes|
|**DELETE**|‚ùå No|‚úÖ Yes|

> **Why does this matter?** In distributed systems, requests can fail and be retried. **Idempotent operations can be safely retried** without causing unintended side effects. Non-idempotent operations (like POST) must be handled more carefully.

---

## üîÑ Stateless Interactions (In Detail)

> _"Systems that follow REST are stateless, meaning the server does not need to know anything about what state the client is in and vice versa."_

Each client request is treated **independently**. The server does not remember previous interactions.

**Benefits of Statelessness:**

1. **Clients are isolated against changes on the server** ‚Äî the server can be upgraded or replaced without affecting clients.
2. **Promotes redundancy and unlocks performance:**
    - Any server in a cluster can handle any request (no session affinity needed).
    - **No synchronization overhead** between servers.
    - If one server fails, the client connects to another and continues ‚Äî because **no state was saved on the failed server**.

---

## üìÑ Representations in REST

**Representation:** A snapshot in time of the **state of a given resource**. It's a sequence of bytes made up of:

- **Data** (the actual content)
- **Representation metadata** (describes those bytes ‚Äî format, encoding, etc.)

**Key points:**

- Resources are **decoupled from their representations** ‚Äî the same resource can be represented in multiple formats (HTML, JSON, XML, PDF, JPEG, etc.).
- The **data format** is called the **media type** (also known as MIME type).
- MIME types identify the specification for **how to process** a representation.
- The message type in REST is **hypermedia** ‚Äî content that contains **links to other forms of media and resources**.
- Navigating hypermedia links is like **browsing web pages** by clicking hyperlinks.
- All response representations must be **self-descriptive**.

**Example MIME types:** `application/json`, `text/html`, `image/jpeg`, `application/pdf`

---

## üì® Self-Descriptive Messages

Each message must contain **enough information to describe how to process it** ‚Äî intermediaries (like proxies, caches) can act on messages without parsing the entire content.

- In REST, resources are decoupled from their representation, so their content can be accessed in various formats (HTML, XML, MIME, plain text, PDF, JPEG, JSON, etc.).
- RESTful systems **empower clients to ask for data in a format they understand**.
- **Metadata** (like Content-Type, Cache-Control headers) is available and used for cache control, error detection, authentication, and access control.

---

## üåê Web Services

**Web Service Definition:**

> _"A software system designed to support interoperable machine-to-machine interaction over a network."_

- A web service is a **self-contained, self-describing, modular application** designed to be used by other software across the web.
- Once deployed, other applications can **discover and invoke** the service.
- A web service is one of the most common implementations of SOA.

**Two prominent ways to implement Web Services:**

1. **SOAP** (Simple Object Access Protocol)
2. **REST** (already discussed at length)

---

## üì¨ SOAP ‚Äî Simple Object Access Protocol

SOAP was designed **before REST** to ensure programs built on **different platforms and programming languages** could **securely exchange data**.

### What SOAP Provides:

- A structure for transmission of **XML documents** over various Internet protocols (HTTP, SMTP, FTP).

### Structure of a SOAP Message:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ           ENVELOPE              ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ         HEADER            ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  (Authentication info,    ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   routing info, etc.)     ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ          BODY             ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   (The actual payload     ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ    / request / response)  ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

- **Envelope:** Encapsulates the entire SOAP message.
- **Header:** Contains metadata such as **authentication credentials**.
- **Body:** Carries the **payload** of the message.

The payload is **marshaled** (converted to XML) by the sender's SOAP engine and **un-marshaled** (converted back) at the receiver.

**WSDL (Web Service Description Language):** Describes the functionality and interface of the SOAP-based web service. Clients read WSDL to understand how to form valid SOAP requests.

---

## üîÑ SOAP Web Service Workflow (7 Steps)

Using the UDDI (Universal Description, Discovery, and Integration) registry:

1. **Service provider publishes** its location and WSDL description to the **UDDI registry**.
2. **Service requester queries** the UDDI registry by name/identifier. The registry returns the **WSDL document**.
3. **Service requester reads** the WSDL document and **forms a SOAP message** binding to all constraints defined in WSDL.
4. **SOAP message is sent** to the web service as the body of an HTTP/SMTP/FTP request.
5. **Web service unpacks** the SOAP request, converts it into a command the application understands, and **executes** it.
6. **Web service packages the response** into a SOAP message and sends it back.
7. **Client unpacks** the SOAP message to obtain the results.

---

## üìä REST vs. SOAP ‚Äî Complete Comparison

|Feature|REST|SOAP|
|---|---|---|
|**Type**|Architectural style|Protocol|
|**Data format**|JSON, XML, HTML, plain text (flexible)|XML only|
|**Transport protocol**|Primarily HTTP|HTTP, SMTP, FTP, others|
|**Message structure**|No fixed structure; uses HTTP natively|Strict Envelope/Header/Body structure|
|**Statefulness**|Stateless|Can be stateful|
|**Complexity**|Simple, lightweight|Complex, verbose|
|**Performance**|Better (less overhead)|Heavier (XML parsing overhead)|
|**WSDL required**|No|Yes|
|**Caching**|Supported natively|Not natively supported|
|**Security**|HTTPS, OAuth|WS-Security (built-in)|
|**Use case**|Web/mobile apps, microservices|Enterprise services, financial transactions|
|**Discovery**|URI-based|UDDI registry|

---

## ‚ùì Q&A Bank ‚Äî REST and Web Services

**Q1. What is SOA?**

> A: Service Oriented Architecture ‚Äî a design approach where software components expose discrete business functions as services with standard interfaces, enabling loose coupling and reuse across applications.

**Q2. Define REST in one sentence.**

> A: REST is an architectural style that defines constraints for building scalable, stateless, client-server systems on the web using standard HTTP operations and URIs to manipulate resources.

**Q3. What are the 5 REST constraints?**

> A: (1) Client-Server, (2) Stateless, (3) Cache, (4) Uniform Interface, (5) Layered System.

**Q4. What is the Stateless Constraint and why does it benefit distributed systems?**

> A: Each request must contain all information needed for the server to respond; the server stores no client state between requests. This allows any server in a cluster to handle any request, enabling load balancing and fault tolerance.

**Q5. What are the 4 sub-constraints of the Uniform Interface Constraint?**

> A: (a) Resource Identification via URI, (b) Manipulation through Representations, (c) Self-Descriptive Messages, (d) HATEOAS ‚Äî Hypermedia as the Engine of Application State.

**Q6. What is a URI and what role does it play in REST?**

> A: A Uniform Resource Identifier uniquely identifies a resource. In REST, clients can only access resources through URIs, which provide a global addressing space.

**Q7. What are the 4 HTTP methods used in REST and what CRUD operation does each map to?**

> A: GET = Read, POST = Create, PUT = Create/Update (full replacement), DELETE = Delete.

**Q8. What does "Idempotent" mean? Which HTTP methods are idempotent?**

> A: An operation is idempotent if calling it multiple times produces the same result as calling it once. GET, PUT, and DELETE are idempotent. POST is not.

**Q9. What does "Safe" mean for an HTTP method? Which methods are safe?**

> A: A safe method does not modify any resources. Only GET is safe ‚Äî it only reads data.

**Q10. Why is POST not idempotent?**

> A: Because calling POST multiple times creates multiple new resources. For example, `POST /books` twice creates two books, not one.

**Q11. What is a "Representation" in REST?**

> A: A snapshot of a resource's current state at a point in time, expressed as a sequence of bytes with metadata describing the format. The same resource can be represented in multiple formats (JSON, XML, HTML, etc.).

**Q12. What is HATEOAS?**

> A: Hypermedia As The Engine Of Application State ‚Äî the principle that REST API responses include hypermedia links to related resources and available actions, allowing clients to navigate the API dynamically without needing to hardcode URLs.

**Q13. What is the Layered System constraint?**

> A: Intermediate components (load balancers, proxies, firewalls) can be inserted between client and server. Each layer only sees the adjacent layer; client-server interaction remains unchanged regardless of what's in between.

**Q14. What is a SOAP message structure?**

> A: A SOAP message has an Envelope containing a Header (authentication and routing metadata) and a Body (the actual payload).

**Q15. What is WSDL and why is it needed for SOAP?**

> A: Web Service Description Language ‚Äî it describes the interface of a SOAP web service (what operations it supports, what parameters they take, what they return). Clients read WSDL to know how to form valid SOAP requests.

**Q16. What is the UDDI Registry?**

> A: Universal Description, Discovery, and Integration ‚Äî a registry where SOAP web service providers publish their service descriptions. Clients query the UDDI to discover and obtain WSDL documents for services.

**Q17. What is the key difference between REST and HTTP?**

> A: REST is an architectural style; HTTP is a protocol. HTTP can be used in non-RESTful ways (e.g., SOAP also uses HTTP). REST defines a set of constraints; compliance with those constraints makes an API RESTful.

**Q18. Why is REST preferred over SOAP for modern web and mobile applications?**

> A: REST is lighter (JSON vs XML), simpler to implement, natively cacheable, and stateless ‚Äî making it faster and more scalable. SOAP's verbosity and complexity are often unnecessary for web/mobile use cases.

**Q19. What is the Cache Constraint and how does it improve performance?**

> A: The Cache Constraint requires server responses to be labeled as cacheable or non-cacheable. Cacheable responses can be stored by the client and reused for repeated requests, reducing server load and network traffic.

**Q20. In the SOAP workflow, what triggers the entire process?**

> A: The service requester querying the UDDI registry. This returns the WSDL, which the requester uses to form a SOAP message to invoke the service.

---

# üìù Final Master Q&A ‚Äî Cross-Topic Questions (Part 2)

These questions test your ability to **connect and synthesize concepts** across all topics.

**Q1. How does the Client-Server architecture model directly relate to the structure of a RESTful web service?**

> A: REST is fundamentally a client-server architecture. The Stateless Constraint and Uniform Interface Constraint in REST directly enforce the separation of concerns principle of the Client-Server model ‚Äî clients and servers evolve independently.

**Q2. A company is choosing between using IaaS to host a web application vs. using a PaaS. What key factors should drive this decision?**

> A: Use IaaS if the team needs specific OS versions, custom middleware, or full control over the stack. Use PaaS if the team wants to focus purely on development without managing infrastructure, and the available PaaS middleware fits their needs.

**Q3. How does the concept of "statelessness" in REST relate to the "scalability" challenge in cloud computing?**

> A: Stateless servers can be replicated freely ‚Äî any instance can handle any request. This directly enables horizontal scaling (adding more server instances) without session synchronization, which is a core technique for addressing the scalability challenge in cloud.

**Q4. How do Fault Models in distributed systems relate to the Reliability and Availability challenges in cloud computing?**

> A: Fault Models categorize what can go wrong (omission, arbitrary, timing). Cloud systems use heartbeats and probes (failure detection) and checkpoint/restart (recovery) ‚Äî these are practical implementations of building fault-tolerant systems based on fault model analysis.

**Q5. Why would a Market-Oriented Cloud Architecture use economic incentives (pricing mechanisms) to solve the scalability problem?**

> A: When resources are priced based on QoS, users naturally consume only what they need, and providers can allocate resources where demand is highest. Price signals balance supply and demand automatically, preventing overload.

**Q6. How does the Layered System Constraint in REST relate to the Cloud Architecture concept of intermediary components?**

> A: Both describe the same principle ‚Äî intermediate components (load balancers, proxies, caches) can be inserted between communicating parties without either party needing to know they exist. This enables transparent scaling and security enforcement in both REST APIs and cloud architectures.

**Q7. How does Google Colab demonstrate the PaaS programming model concept?**

> A: Colab gives developers a managed runtime environment where they specify what code to run (the "application") and Google's PaaS layer handles resource allocation, environment setup, GPU access, and scaling ‚Äî exactly mirroring the PaaS model of uploading an application and having the platform manage the infrastructure.

**Q8. How does the Asynchronous Distributed System model relate to why REST is stateless?**

> A: Asynchronous systems cannot rely on timing or ordering guarantees. REST's statelessness is a natural fit ‚Äî since you can't guarantee message order or timing, making each request self-contained eliminates dependency on prior state, making the system resilient to the unpredictability of asynchronous networks.

**Q9. A startup is building a photo-sharing app. Map the three service models (IaaS, PaaS, SaaS) to three different team types who might build or use this app.**

> A: An infrastructure team uses **IaaS** to provision the VMs and storage. The development team uses **PaaS** to build and deploy the application without managing infrastructure. End users use the finished photo-sharing app as **SaaS** ‚Äî just logging in and sharing photos via a browser.

**Q10. How do the concepts of "self-descriptive messages" in REST and "fault-tolerant systems" in distributed computing both address the same underlying engineering challenge?**

> A: Both address the challenge of systems functioning correctly without relying on shared context or prior knowledge. Self-descriptive messages ensure every message can be understood independently (no prior state needed). Fault-tolerant systems are designed to function correctly even when components behave unexpectedly. Both are responses to the unreliability and unpredictability inherent in distributed computing.

---

_üìö Notebook Part 2 complete. Together with Part 1, you now have comprehensive coverage of all 10 lectures._ _All content sourced from lecture slides by Dr. Prafullata Kiran Auradkar, Dept. of CSE_