# A Tutor's Guide to Advanced SQL Mastery

### Introduction: Beyond Basic Queries

"Advanced SQL" refers to a powerful set of features that extend beyond the foundational `SELECT`, `INSERT`, `UPDATE`, and `DELETE` commands. This guide moves past simple data retrieval to explore sophisticated capabilities that allow you to embed complex business logic, perform nuanced analysis, and achieve significant performance enhancements directly within the database. By mastering these tools, you can create more efficient, modular, and powerful data-driven applications.

This document aims to provide a thorough and practical understanding of key advanced SQL concepts, including stored procedures, functions, Common Table Expressions (CTEs), window functions, and full-text search. Our objective is to empower you with the knowledge to apply these techniques confidently in real-world scenarios.

--------------------------------------------------------------------------------

## 1.0 Encapsulating Business Logic: Functions and Stored Procedures

A crucial step in developing sophisticated database applications is embedding "business logic" directly into the database itself. Using User-Defined Functions (UDFs) and Stored Procedures, we can create reusable, server-side code blocks that perform specific tasks. This strategy is highly beneficial, as it reduces code duplication across multiple applications, improves overall software modularity by centralizing logic, and minimizes the amount of data that needs to be transferred between an application and the database server. This reduction in data transfer is key to performance, as it avoids network latency and the computational overhead of data serialization and deserialization between the application and database tiers.

### 1.1 Understanding User-Defined Functions (UDFs)

A User-Defined Function (UDF) is a routine created by a developer that accepts parameters, performs an action—such as a complex calculation—and returns a result. These functions are stored within the database and can be invoked directly from SQL statements, much like built-in functions like `COUNT()` or `SUM()`.

The key advantages of using UDFs include:

- **Simplified Development:** They encapsulate complex formulas or logic, which can then be used in multiple queries without rewriting the code.
- **Code Reusability:** Once defined, a function can be reused anywhere it's needed, ensuring consistency and reducing development effort.
- **Improved Readability:** Replacing complex calculations in a `SELECT` statement with a single, well-named function makes queries much easier to read and understand.

The general syntax for creating a function is as follows:

```sql
CREATE FUNCTION schema_name.function_name (parameter_list)
RETURNS data_type AS
BEGIN
    statements
    RETURN value
END
```

Here is a breakdown of the syntax components:

|   |   |
|---|---|
|Component|Description|
|`function_name`|The name you assign to the function.|
|`parameter_list`|An optional list of input parameters the function accepts. A function can have zero, one, or multiple parameters.|
|`RETURNS data_type`|Specifies the data type of the single value that the function will return.|
|`BEGIN / END`|These keywords mark the start and end of the function's body, which contains the SQL statements.|
|`RETURN value`|This statement terminates the function's execution and returns the specified value to the caller.|

When creating a function, you can also specify whether it is `DETERMINISTIC` or `NON-DETERMINISTIC`. A **deterministic** function always returns the same result for the same set of input parameters. A **non-deterministic** function may return different results each time it is called, even with the same inputs (e.g., a function that calls `current_date()`). By default, functions are considered `NON-DETERMINISTIC`.

To remove a function from the database, you use the `DROP FUNCTION` command:

```sql
DROP FUNCTION IF EXISTS function_name;
```

### 1.2 Practical Application: Function Examples

Let's examine two practical examples to see UDFs in action.

**Example 1: Determine Department Size**

This function takes a department number as input and returns a text label ('HUGE', 'LARGE', 'MEDIUM', 'SMALL') based on the number of employees in that department.

```sql
CREATE FUNCTION Dept_size(deptno INT) RETURNS VARCHAR(7)
BEGIN
    DECLARE No_of_emps INT;
    SELECT COUNT(*) INTO No_of_emps FROM EMPLOYEE WHERE Dno = deptno;
    IF No_of_emps > 3 THEN
        RETURN 'HUGE';
    ELSEIF No_of_emps > 2 THEN
        RETURN 'LARGE';
    ELSEIF No_of_emps > 1 THEN
        RETURN 'MEDIUM';
    ELSE
        RETURN 'SMALL';
    END IF;
END
```

The logic is straightforward: it declares a variable `No_of_emps`, counts the employees for the given `deptno` and stores the result in that variable, and then uses an `IF/ELSEIF/ELSE` block to return the appropriate string.

We can invoke this function in a `SELECT` query:

```sql
SELECT Dname,Dnumber,Dept_size(Dnumber) FROM department;
```

The output would be:

|   |   |   |
|---|---|---|
|Dname|Dnumber|Dept_size(Dnumber)|
|Administration|4|HUGE|
|Headquarters|1|SMALL|
|Research|5|HUGE|

**Example 2: Calculate Employee Age**

This function calculates an employee's age based on their birth date.

```sql
CREATE FUNCTION no_of_years(date1 DATE)
RETURNS INTEGER DETERMINISTIC
BEGIN
    DECLARE date2 DATE;
    SELECT current_date() INTO date2;
    RETURN year(date2)-year(date1);
END
```

This function takes a birth date (`date1`), gets the current date, and returns the difference in years. Note that while the source example marks this function as `DETERMINISTIC`, any function that relies on `current_date()` or `now()` is inherently **non-deterministic**, as its output changes depending on when it is executed. For a function to be truly deterministic, it must always return the same output for the same input parameters. We present the code as is from the source for fidelity, but in a real-world scenario, this function should be correctly classified as non-deterministic.

We can invoke it like this:

```sql
SELECT Fname,no_of_years(Bdate) FROM employee;
```

The resulting output would be:

|   |   |
|---|---|
|Fname|no_of_years(Bdate)|
|John|58|
|Franklin|68|
|Joyce|51|
|Richard|61|
|Ramesh|61|
|James|86|
|Jennifer|82|
|Ahmed|54|
|Alicia|55|

### 1.3 Demystifying Stored Procedures

A stored procedure is a collection of pre-compiled SQL statements stored in the database. Unlike a function, which is designed to return a single value and be used in expressions, a procedure is a more robust subprogram. It can perform a series of operations, modify the database, and return multiple result sets. Procedures can be invoked by applications, triggers, or even other stored procedures.

Stored procedures are most useful in the following circumstances:

- **Improved Modularity:** When a database program is needed by several applications, it can be stored on the server and invoked by any client, reducing code duplication.
- **Reduced Communication Costs:** Executing a complex series of statements on the server can significantly reduce data transfer between the client and the database.
- **Enhanced Data Modeling:** Procedures can provide more complex views of derived data than are possible with standard `VIEW` objects.
- **Complex Constraint Enforcement:** They can be used to check for complex business rules that go beyond the capabilities of standard constraints and triggers.

The general syntax for creating a procedure is:

```sql
CREATE PROCEDURE procedure_name ([IN | OUT | INOUT] parameter_name datatype [, ...])
BEGIN
   Declaration_section
   Executable_section
END
```

Note: The `DELIMITER` command is a directive specific to clients like the MySQL command-line tool, used to change the statement terminator so the procedure's body can be parsed as a single block. It is not part of the core SQL syntax for the procedure itself, and is omitted here for clarity.

Procedures support three parameter modes, which offer greater flexibility than functions:

|   |   |
|---|---|
|Mode|Purpose|
|`IN`|This is the default mode. The parameter is an **input** value passed to the procedure. The calling program must provide an argument, and its value is protected (cannot be changed by the procedure).|
|`OUT`|The parameter is an **output** value. The procedure can change its value, and the new value is passed back to the calling program. The procedure cannot access the initial value of an `OUT` parameter.|
|`INOUT`|This parameter is a combination of `IN` and `OUT`. The calling program passes in an initial value, the procedure can **modify** it, and the new value is passed back to the caller.|

### 1.4 Stored Procedure Examples in Action

The following examples demonstrate the versatility of stored procedures, progressing from a simple, parameter-less procedure that returns static result sets to more dynamic procedures that use `IN`, `OUT`, and `INOUT` parameters to interact with the calling environment.

**Procedure without Parameters**

This procedure, `get_merit_student`, executes two separate `SELECT` statements: one to retrieve students with marks greater than 70, and another to count the total number of students.

```sql
CREATE PROCEDURE `get_merit_student`()
BEGIN
    SELECT * FROM student WHERE marks > 70;
    SELECT COUNT(student_code) AS Total_Student FROM student;
END
```

When called, it would return two result sets. The second result set would contain:

|   |
|---|
|Total_Student|
|9|

**Procedure with an** `**IN**` **Parameter**

The `get_student` procedure accepts an integer `var1` and uses it in a `LIMIT` clause to control how many student records are returned.

```sql
CREATE PROCEDURE get_student (IN var1 INT)
BEGIN
    SELECT * FROM student_info LIMIT var1;
    SELECT COUNT(stud_code) AS Total_Student FROM student_info;
END
```

Calling `CALL get_student(3);` returns the first three students:

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|student_id|student_code|student_name|subject|marks|phone|
|1|101|Mark|English|68|3454569353|
|2|102|Joseph|Physics|70|9876543565|
|3|103|John|maths|70|9765326975|

Calling `CALL get_student(5);` returns the first five students:

|   |   |   |   |   |   |
|---|---|---|---|---|---|
|student_id|student_code|student_name|subject|marks|phone|
|1|101|Mark|English|68|3454569353|
|2|102|Joseph|Physics|70|9876543565|
|3|103|John|maths|70|9765326975|
|4|104|Barack|maths|90|8769875325|
|5|105|Rinky|maths|85|6753157975|

**Procedure with an** `**OUT**` **Parameter**

The `display_max_mark` procedure finds the maximum mark in the `student` table and stores it `INTO` the `highestmark` output parameter.

```sql
CREATE PROCEDURE `display_max_mark` (OUT highestmark INTEGER)
BEGIN
    SELECT MAX(marks) INTO highestmark FROM student;
END
```

To call it, you pass a session variable to receive the output: `CALL display_max_mark(@output);` After execution, `@output` will contain:

|   |
|---|
|@output|
|92|

**Procedure with an** `**INOUT**` **Parameter**

This procedure, `display_marks`, uses the `var1` parameter first as an input to find a student by `stud_id`, and then as an output to store that student's marks.

```sql
CREATE PROCEDURE `display_marks` (INOUT var1 INTEGER)
BEGIN
    SELECT marks INTO var1 FROM student WHERE stud_id = var1;
END
```

Calling it requires setting the variable first: `SET @M = '3'; CALL display_marks(@M); SELECT @M;`

|   |
|---|
|@M|
|70|

`SET @M = '4'; CALL display_marks(@M); SELECT @M;`

|   |
|---|
|@M|
|90|

**Procedure with Control Flow Logic**

Stored procedures can also contain procedural logic like loops and conditional statements, allowing for more complex operations. The following example uses a `WHILE` loop and an `IF/ELSE` block.

```sql
CREATE PROCEDURE StudentMarksWithLoop()
BEGIN
    DECLARE done INT DEFAULT 0;
    DECLARE marks INT;
    DECLARE student_name VARCHAR(25);
    WHILE done = 0 DO
        SELECT marks, student_name INTO marks, student_name
        FROM student
        WHERE done = 0
        LIMIT 1;
        IF marks >= 50 THEN
            SELECT CONCAT(student_name, ' passed') AS Result;
        ELSE
            SELECT CONCAT(student_name, ' failed') AS Result;
        END IF;
        SET done = 1;
    END WHILE;
END
```

This procedure is designed to process one student at a time. It retrieves the marks for the first student it finds, uses an `IF` statement to determine if they passed or failed, and then immediately sets `done = 1` to exit the `WHILE` loop.

To manage procedures, you can delete them with `DROP PROCEDURE` or view existing ones with `SHOW PROCEDURE STATUS`.

```sql
DROP PROCEDURE [IF EXISTS] procedure_name;
SHOW PROCEDURE STATUS WHERE db = 'your_database_name';
```

### 1.5 Head-to-Head: Stored Procedures vs. Functions

While both serve to encapsulate logic, they have fundamental differences in their capabilities and use cases.

|   |   |
|---|---|
|Stored Procedure|Function|
|Supports `in`, `out`, and `in-out` parameters.|Supports only input parameters.|
|Can call functions as needed.|Cannot call a stored procedure.|
|Cannot be called directly from `select`/`having`/`where` statements.|Can be called from a `select` statement.|
|Transactions can be used inside stored procedures.|No transactions are allowed.|
|Can perform exception handling using `try`/`catch` blocks.|No provision for explicit exception handling.|
|Does not need to return any value.|Must return a result or value to the caller.|
|All database operations (`insert`, `update`, `delete`) can be performed.|Only `select` is allowed.|

Now that we understand how to encapsulate logic, let's explore ways to structure complex queries and embed conditional logic directly within them.

--------------------------------------------------------------------------------

## 2.0 Advanced Query Structuring and Conditional Logic

Modern SQL provides powerful constructs for organizing queries and embedding conditional logic. This section introduces Common Table Expressions (CTEs) and the `CASE` statement. We can frame these as tools for managing different kinds of complexity: CTEs help manage _logical complexity_ by breaking down multi-step queries into readable blocks, while `CASE` manages _computational complexity_ at the row level by allowing for in-query conditional processing.

### 2.1 Simplifying Complexity with Common Table Expressions (CTEs)

A **Recursive CTE** is a special type of Common Table Expression that references itself. This self-referencing capability makes it exceptionally useful for working with hierarchical or graph-like data structures, such as an organizational chart (employee-supervisor relationships) or a bill of materials. The CTE continues to execute until the query has traversed the entire hierarchy.

The general syntax for a recursive CTE uses the `WITH RECURSIVE` clause:

```sql
WITH RECURSIVE cte_name (column_list) AS (
    -- Anchor member: The initial query that forms the base case
    SELECT ...
    FROM ...
    WHERE ...
UNION ALL
    -- Recursive member: The query that refers to the CTE itself
    SELECT ...
    FROM cte_name -- Refer to the CTE within itself
    WHERE ...
)
-- The final SELECT statement outside the CTE to retrieve the result
SELECT * FROM cte_name;
```

A recursive CTE is composed of three key parts:

- **Anchor Member:** This is the base query that runs first and does not reference the CTE itself. It establishes the starting point for the recursion (e.g., the CEO of a company, who has no supervisor).
- **Recursive Member:** This query references the CTE (`cte_name`) and is joined with other tables to find the next level of the hierarchy. It must include a termination condition to prevent an infinite loop.
- **UNION ALL:** This operator combines the results from the anchor member with the results from each iteration of the recursive member.

The execution flow is iterative. The database engine first runs the anchor query. Then, in each subsequent step, it runs the recursive query using the results from the previous step as its input, until the recursive member produces no more rows.

For example, this simple CTE counts from 1 to 5:

```sql
WITH RECURSIVE cte(n) AS (
    -- Anchor part of the query
    SELECT 1
    UNION ALL
    -- Recursive part of the query
    SELECT n + 1 FROM cte WHERE n < 5
)
SELECT * FROM cte;
```

**Execution Flow:**

1. **Anchor Execution:** `SELECT 1` runs, producing the initial result set `{1}`.
2. **First Recursion:** The recursive member runs with `cte` containing `{1}`. `SELECT 1 + 1 FROM cte WHERE 1 < 5` produces `{2}`. The result set is now `{1, 2}`.
3. **Second Recursion:** The recursive member runs with `cte` containing `{2}`. `SELECT 2 + 1 FROM cte WHERE 2 < 5` produces `{3}`. The result set is now `{1, 2, 3}`.
4. This continues until `n` is 5. When the recursive member runs with `cte` containing `{5}`, the `WHERE n < 5` condition is false, and the recursion terminates.

**Practical Application: Organizational Hierarchy**

Here is a query to extract an entire organizational reporting structure, starting from the employee with no supervisor (`super_ssn is null`).

```sql
WITH RECURSIVE orghierarchy AS(
  SELECT ssn,fname,lname,super_ssn, 1 AS level
  FROM employee
  WHERE super_ssn IS NULL
  UNION ALL
  SELECT e.ssn,e.fname,e.lname,e.super_ssn, OH.level+1
  FROM employee e
  JOIN orghierarchy OH ON e.super_ssn=OH.ssn
)
SELECT * FROM orghierarchy;
```

The final output clearly displays the reporting lines and hierarchy level for each employee:

|   |   |   |   |   |
|---|---|---|---|---|
|ssn|fname|lname|super_ssn|level|
|888665555|James|Borg|NULL|1|
|123456789|John|Smith|888665555|2|
|333445555|Franklin|Wong|888665555|2|
|453453453|Joyce|English|333445555|3|
|666884444|Ramesh|Narayan|333445555|3|
|987654321|Jennifer|Wallace|333445555|3|
|999887777|Alicia|Zelaya|333445555|3|
|987987987|Ahmed|Jabbar|987654321|4|

### 2.2 Embedding Logic with the `CASE` Statement

The `CASE` statement is a versatile conditional expression in SQL that allows you to embed `if-then-else` logic directly into a query. Its primary use cases are creating new, derived columns based on conditional logic and controlling query outputs. If no condition is met and no `ELSE` clause is specified, `CASE` returns `NULL`.

The general syntax is:

```sql
CASE
    WHEN condition1 THEN result1
    WHEN condition2 THEN result2
    ...
    ELSE result
END
```

**Example 1: Categorize Employee Salaries**

This query creates a new column, `Salary_Level`, to categorize employees as 'High', 'Medium', or 'Low' based on their salary.

```sql
SELECT Fname, Salary,
    CASE
        WHEN Salary >= 55000 THEN 'High'
        WHEN Salary >= 40000 THEN 'Medium'
        ELSE 'Low'
    END AS Salary_Level
FROM employee;
```

**Output:**

|   |   |   |
|---|---|---|
|Fname|Salary|Salary_Level|
|John|30000.00|Low|
|Franklin|40000.00|Medium|
|Joyce|25000.00|Low|
|Ramesh|38000.00|Low|
|James|55000.00|High|
|Jennifer|43000.00|Medium|
|Ahmed|25000.00|Low|
|Alicia|25000.00|Low|

**Example 2: Determine Bonus Eligibility**

This query creates a `Bonus_Status` column to determine employee eligibility for different bonus tiers.

```sql
SELECT Fname, Salary,
    CASE
        WHEN Salary >= 50000 THEN 'Eligible for 20% Bonus'
        WHEN Salary >= 40000 THEN 'Eligible for 10% Bonus'
        ELSE 'No Bonus'
    END AS Bonus_Status
FROM employee;
```

**Output:**

|   |   |   |
|---|---|---|
|Fname|Salary|Bonus_Status|
|John|30000.00|No Bonus|
|Franklin|40000.00|Eligible for 10% Bonus|
|Joyce|25000.00|No Bonus|
|Ramesh|38000.00|No Bonus|
|James|55000.00|Eligible for 20% Bonus|
|Jennifer|43000.00|Eligible for 10% Bonus|
|Ahmed|25000.00|No Bonus|
|Alicia|25000.00|No Bonus|

**Example 3: Assess Employee Workload**

This query joins the `employee` and `works_on` tables, counts the number of projects for each employee, and then uses a `CASE` statement to assign a workload status.

```sql
SELECT
    e.Fname,
    COUNT(w.Pno) AS Project_Count,
    CASE
        WHEN COUNT(w.Pno) >= 3 THEN 'Overloaded'
        WHEN COUNT(w.Pno) = 2 THEN 'Normal Load'
        ELSE 'Light Load'
    END AS Workload_Status
FROM employee e
LEFT JOIN works_on w ON e.Ssn = w.Essn
GROUP BY e.Fname;
```

The `GROUP BY` clause is essential here; without it, `COUNT()` would operate on the entire table rather than calculating a per-employee total.

**Output:**

|   |   |   |
|---|---|---|
|Fname|Project_Count|Workload_Status|
|John|2|Normal Load|
|Franklin|4|Overloaded|
|Joyce|2|Normal Load|
|Ramesh|1|Light Load|
|James|1|Light Load|
|Jennifer|2|Normal Load|
|Ahmed|2|Normal Load|
|Alicia|2|Normal Load|

For improved readability, especially in more complex queries, this same logic can be structured using a CTE.

```sql
WITH Project_Counts AS (
    SELECT
        e.Fname,
        COUNT(w.Pno) AS Proj_Count
    FROM employee e
    LEFT JOIN works_on w ON e.Ssn = w.Essn
    GROUP BY e.Fname
)
SELECT
    Fname,
    Proj_Count,
    CASE
        WHEN Proj_Count >= 3 THEN 'Overloaded'
        WHEN Proj_Count = 2 THEN 'Normal Load'
        ELSE 'Light Load'
    END AS Workload_Status
FROM Project_Counts;
```

While the `CASE` statement allows for conditional logic on a row-by-row basis, window functions unlock the ability to perform complex calculations across sets of rows.

--------------------------------------------------------------------------------

## 3.0 Unlocking Row-Level Analytics: Window Functions

Window functions are a class of SQL functions that perform calculations across a set of rows related to the current row. Their defining and most powerful characteristic is that they do **not** collapse the result set like traditional aggregate functions (`GROUP BY`). Instead, they return a value for _each row_ based on a "window" of related rows, allowing you to blend aggregated insights with row-level detail in a single query.

To understand this critical difference, consider calculating the average salary per department.

With a standard `GROUP BY`, the query collapses the data, losing individual employee details: `SELECT department, AVG(salary) FROM employees GROUP BY department;`

|   |   |
|---|---|
|department|AVG(salary)|
|Sales|6500.0000|
|Engineering|8500.0000|
|HR|6000.0000|

With a window function, the query preserves every employee row while adding the departmental average: `SELECT emp_name, department, salary, AVG(salary) OVER (PARTITION BY department) AS dept_avg_salary FROM employees;`

|   |   |   |   |
|---|---|---|---|
|emp_name|department|salary|dept_avg_salary|
|Charlie|Engineering|9000|8500.0000|
|David|Engineering|8000|8500.0000|
|Eva|HR|6000|6000.0000|
|Alice|Sales|5000|6500.0000|
|Bob|Sales|7000|6500.0000|
|Frank|Sales|7500|6500.0000|

This capability makes window functions indispensable for many common analytical tasks:

- **Ranking:** Assigning ranks or row numbers (e.g., top 10 sales per region).
- **Running Totals:** Calculating cumulative sums over time.
- **Moving Averages:** Analyzing trends by averaging values over a sliding window.
- **Lag/Lead Analysis:** Comparing a row's value with values from preceding or succeeding rows.

The general syntax for a window function is: `window_function(column) OVER([PARTITION BY column] [ORDER BY column])`

- `window_function`: The function to apply (e.g., `SUM`, `RANK`).
- `OVER()`: This clause is what designates it as a window function.
- `PARTITION BY`: This optional clause divides the rows into logical groups, or "windows" (e.g., `PARTITION BY department`). The function is applied independently to each partition.

### 3.1 Types of Window Functions

Window functions can be categorized into three main types:

1. **Aggregate functions** (`SUM`, `AVG`, `COUNT`, etc.)
2. **Ranking functions** (`RANK`, `DENSE_RANK`, `ROW_NUMBER`)
3. **Value functions** (`LAG`, `LEAD`)

### 3.2 Aggregate Window Functions

Standard aggregate functions can be used as window functions by adding the `OVER()` clause.

**Example: Maximum Salary per Department** This query finds the maximum salary within each department and displays it alongside each employee's record.

```sql
SELECT Emp_ID, emp_name, Department, Salary,
       MAX(Salary) OVER (PARTITION BY Department) AS MaxDeptSalary
FROM Employees;
```

**Output:**

|   |   |   |   |   |
|---|---|---|---|---|
|Emp_ID|emp_name|Department|Salary|MaxDeptSalary|
|103|Charlie|Engineering|9000|9000|
|104|David|Engineering|8000|9000|
|105|Eva|HR|6000|6000|
|101|Alice|Sales|5000|7500|
|102|Bob|Sales|7000|7500|
|106|Frank|Sales|7500|7500|

**Example: Employee Count per Department** This query counts the number of employees in each department.

```sql
SELECT Emp_ID, emp_name, Department, Salary,
       COUNT(*) OVER (PARTITION BY Department) AS DeptEmployeeCount
FROM Employees;
```

**Output:**

|   |   |   |   |   |
|---|---|---|---|---|
|Emp_ID|emp_name|Department|Salary|DeptEmployeeCount|
|103|Charlie|Engineering|9000|2|
|104|David|Engineering|8000|2|
|105|Eva|HR|6000|1|
|101|Alice|Sales|5000|3|
|102|Bob|Sales|7000|3|
|106|Frank|Sales|7500|3|

### 3.3 Ranking Window Functions

Ranking functions assign a numerical rank to each row within a partition, based on the criteria specified in an `ORDER BY` clause.

`**RANK()**` Assigns a rank to each row. If two rows have the same value (a tie), they receive the same rank. The rank counter then increments by the number of tied rows in the preceding rank. For example, if two rows tie for rank 1, the counter increments by two, and the next rank assigned is 3.

```sql
SELECT emp_name, department, salary,
       RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS rank_in_dept
FROM Employees;
```

**Output:** (Notice Bob and Frank tie for rank 1, and Alice is rank 3)

|   |   |   |   |
|---|---|---|---|
|emp_name|department|salary|rank_in_dept|
|Charlie|Engineering|9000|1|
|David|Engineering|8000|2|
|Eva|HR|6000|1|
|Bob|Sales|7000|1|
|Frank|Sales|7000|1|
|Alice|Sales|5000|3|

`**DENSE_RANK()**` Similar to `RANK()`, but it does **not** skip ranks after a tie. If two employees tie for 1st place, the next employee is ranked 2nd.

```sql
SELECT emp_name, department, salary,
       DENSE_RANK() OVER (PARTITION BY department ORDER BY salary DESC) AS dense_rank_in_dept
FROM Employees;
```

**Output:** (Notice Bob and Frank tie for rank 1, and Alice is now rank 2)

|   |   |   |   |
|---|---|---|---|
|emp_name|department|salary|dense_rank_in_dept|
|Charlie|Engineering|9000|1|
|David|Engineering|8000|2|
|Eva|HR|6000|1|
|Bob|Sales|7000|1|
|Frank|Sales|7000|1|
|Alice|Sales|5000|2|

`**ROW_NUMBER()**` Assigns a unique, sequential integer to each row within a partition. It does not recognize ties; even if values are identical, each row receives a distinct number.

```sql
SELECT emp_name, department, salary,
       ROW_NUMBER() OVER (PARTITION BY department ORDER BY salary DESC) AS row_num_in_dept
FROM Employees;
```

**Output:** (All rows have a unique number within their partition)

|   |   |   |   |
|---|---|---|---|
|emp_name|department|salary|row_num_in_dept|
|Charlie|Engineering|9000|1|
|David|Engineering|8000|2|
|Eva|HR|6000|1|
|Bob|Sales|7000|1|
|Frank|Sales|7000|2|
|Alice|Sales|5000|3|

### 3.4 Value Window Functions

Value functions allow you to access data from other rows within the same result set, such as the previous row or the next row.

`**LAG()**` The `LAG()` function provides access to a value from a _previous_ row in the partition. This is extremely useful for comparing current and past values, like calculating month-over-month growth.

Its syntax is `LAG(column_name, offset, default_value)`. The `offset` determines how many rows to look back (default is 1), and `default_value` is what's returned if there is no preceding row.

```sql
SELECT emp_name, department, salary,
       LAG(salary, 1) OVER (PARTITION BY department ORDER BY salary DESC) AS prev_salary
FROM Employees;
```

**Output:**

|   |   |   |   |
|---|---|---|---|
|emp_name|department|salary|prev_salary|
|Charlie|Engineering|9000|NULL|
|David|Engineering|8000|9000|
|Eva|HR|6000|NULL|
|Bob|Sales|7000|NULL|
|Frank|Sales|7000|7000|
|Alice|Sales|5000|7000|

`**LEAD()**` The `LEAD()` function is the opposite of `LAG()`; it accesses a value from a _future_ row in the partition. This can be used for forecasting or comparing a current value with an upcoming one.

Its syntax is `LEAD(column_name, offset, default_value)`.

```sql
SELECT emp_name, department, salary,
       LEAD(salary, 1) OVER (PARTITION BY department ORDER BY salary DESC) AS next_salary
FROM Employees;
```

**Output:**

|   |   |   |   |
|---|---|---|---|
|emp_name|department|salary|next_salary|
|Charlie|Engineering|9000|8000|
|David|Engineering|8000|NULL|
|Eva|HR|6000|NULL|
|Bob|Sales|7000|7000|
|Frank|Sales|7000|5000|
|Alice|Sales|5000|NULL|

Having mastered numerical and categorical analysis with window functions, we now turn to the specialized challenge of searching and analyzing large blocks of text.

--------------------------------------------------------------------------------

## 4.0 Mastering Text Data: Full-Text Search in MySQL

Full-Text Search (FTS) in MySQL is a specialized feature for searching words or phrases in large text-based columns (`VARCHAR`, `TEXT`). Unlike simple string matching with the `LIKE` operator, FTS uses principles of natural language processing to find relevant matches and, crucially, rank the results based on how well they align with the search terms. This makes it far more powerful for applications like searching articles, product descriptions, or user comments.

The core syntax for FTS is: `MATCH(column) AGAINST('search terms')`

The table below highlights the key differences between traditional string searching and Full-Text Search.

|   |   |   |
|---|---|---|
|Feature|`LIKE` / `REGEXP`|`FULL TEXT SEARCH`|
|**Index Usage**|Does not use indexes effectively. Slow for large data.|Uses special `FULLTEXT` indexes for faster searches.|
|**Relevance Ranking**|No relevance ranking, just returns matches.|Results are ranked by relevance score.|
|**Natural Language Support**|Not supported.|Supported (Natural Language Mode).|
|**Word Boundary Detection**|Inaccurate (matches substrings, e.g., 'cat' in 'concatenate').|Accurate word boundary detection.|
|**Boolean Logic**|Not supported.|Supported (AND, OR, NOT-like operators).|

### 4.1 How Full-Text Search Works

Using FTS involves three fundamental steps:

1. Ensure the target columns are of type `VARCHAR` or `TEXT`.
2. Create a `FULLTEXT INDEX` on the column(s) you intend to search.
3. Use the `MATCH(...) AGAINST(...)` syntax in your `WHERE` clause.

Let's walk through an example. First, we create and populate a `posts` table:

```sql
CREATE TABLE posts (
    id INT UNSIGNED AUTO_INCREMENT NOT NULL PRIMARY KEY,
    title VARCHAR(200),
    body TEXT
) ENGINE=InnoDB;

INSERT INTO posts (title, body) VALUES
('MySQL Tutorial', 'Learn the basics of database systems'),
('Advanced Database', 'We explore indexing and performance'),
('Cooking Tips', 'Always use fresh ingredients'),
('MySQL vs PostgreSQL', 'Comparison of two database systems');
```

Next, we add the necessary `FULLTEXT` index to enable searching on the `title` and `body` columns:

```sql
ALTER TABLE posts ADD FULLTEXT(title, body);
```

Now we can perform a search. This query finds all posts containing the word 'database':

```sql
SELECT * FROM posts
WHERE MATCH (title, body)
AGAINST ('database' IN NATURAL LANGUAGE MODE);
```

**Output:**

|   |   |   |
|---|---|---|
|id|title|body|
|1|MySQL Tutorial|Learn the basics of database systems|
|2|Advanced Database|We explore indexing and performance|
|4|MySQL vs PostgreSQL|Comparison of two database systems|

A core concept in FTS is **Relevance**. This is a numeric score that MySQL calculates to measure the similarity between the search string and the text in a given row. The score is influenced by several factors, including:

- How often the search term appears in the document.
- How rare the term is across all documents in the collection.
- The length of the document (a term found in a shorter document is often considered more relevant).

You can explicitly view this relevance score in your query results and order by it to see the best matches first:

```sql
SELECT id, title,
       MATCH(title, body) AGAINST('database') AS relevance
FROM posts
WHERE MATCH(title, body) AGAINST('database')
ORDER BY relevance DESC;
```

It is important to note that even if you do not explicitly select or order by the relevance score, MySQL will **automatically sort the results by relevance** by default, provided you are using `MATCH(...) AGAINST(...)` in the `WHERE` clause and have not specified another `ORDER BY` clause.

### 4.2 Search Modes: Natural Language vs. Boolean

**Natural Language Mode** is the default search mode. It interprets the search string as a natural phrase and ignores common stopwords (like 'a', 'the', 'is') and, by default, very short words.

**Boolean Mode** provides much greater control by allowing you to perform complex searches using special operators. This mode is activated by adding `IN BOOLEAN MODE` to the `AGAINST()` clause.

Here are the common Boolean operators:

|   |   |
|---|---|
|Operator|Meaning|
|`+`|The word **must** be present.|
|`-`|The word **must not** be present.|
|`(none)`|The word is optional, but rows containing it are ranked higher.|
|`""`|Searches for the **exact phrase** within the quotes.|
|`*`|A wildcard for prefix searches (e.g., `data*` matches 'database').|
|`( )`|Groups terms together to form subexpressions.|

Here are some examples of Boolean Mode queries:

**1. Include one word, exclude another** This finds posts that must contain "mysql" but must not contain "oracle".

```sql
SELECT * FROM posts
WHERE MATCH(title, body) AGAINST('+mysql -oracle' IN BOOLEAN MODE);
```

**2. Exact Phrase Match** This finds posts containing the precise phrase "database systems".

```sql
SELECT * FROM posts
WHERE MATCH(title, body) AGAINST('"database systems"' IN BOOLEAN MODE);
```

**3. Prefix Search with Wildcard** This finds posts containing words that start with "data", such as "data" or "database".

```sql
SELECT * FROM posts
WHERE MATCH(title, body) AGAINST('data*' IN BOOLEAN MODE);
```

--------------------------------------------------------------------------------

By mastering the concepts covered in this guide—from encapsulating logic in procedures and functions to structuring complex queries with CTEs, performing advanced analytics with window functions, and executing intelligent text searches—you have moved far beyond basic SQL. These powerful tools enable you to build more efficient, scalable, and intelligent database solutions, empowering you to solve a wider range of data challenges. The key to true mastery lies in practice, so we encourage you to apply these techniques to your own data and discover the new possibilities they unlock.