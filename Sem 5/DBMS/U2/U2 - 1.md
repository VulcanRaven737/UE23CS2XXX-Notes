# A Comprehensive Guide to Advanced SQL Operations

The core `SELECT` query is the strategic heart of all data retrieval in SQL. It serves as the fundamental building block for interacting with a relational database, providing a structured syntax to specify what data you want, from where, and under what conditions. Every complex analysis, every sophisticated report, and every aggregated insight begins with this foundational structure. Understanding its anatomy is the first and most critical step toward SQL mastery.

This guide will deconstruct each primary clause of a basic and advanced SQL query. By building a strong operational foundation, you will be equipped to move from simple data retrieval to complex data synthesis, joining disparate tables, combining result sets, and correctly handling the nuances of missing information.

## 1.0 The Anatomy of a Foundational SQL Query

### 1.1 Core Data Retrieval: `SELECT` and `FROM`

The most basic data retrieval operation involves two essential clauses: `SELECT` and `FROM`.

- `**SELECT**`: This clause specifies the columns you want to retrieve. In the context of relational algebra, this is known as **projection**.
- `**FROM**`: This clause specifies the source table containing the desired columns.

To find the first and last names of all employees from the `EMPLOYEE` table, the query is structured as follows:

```sql
SELECT Fname, Lname FROM EMPLOYEE;
```

**Example Output:**

|   |   |
|---|---|
|Fname|Lname|
|John|Smith|
|John|Smith|
|Franklin|Wong|
|Joyce|English|
|Ramesh|Narayan|
|James|Borg|
|Jennifer|Wallace|
|Ahmed|Jabbar|
|Alicia|Zelaya|

**Note:** SQL keywords and names are case-insensitive. For example, `Name` is equivalent to `NAME` and `name`.

### 1.2 Filtering Data: The `WHERE` Clause

The `WHERE` clause is the primary mechanism for filtering rows based on specific conditions. It corresponds to the **selection predicate** in relational algebra, allowing you to include only the rows that satisfy the criteria you define.

For instance, to find all employees in department number 5, you would add a `WHERE` clause:

```sql
SELECT fname, dno FROM EMPLOYEE WHERE dno = 5;
```

**Example Output:**

|   |   |
|---|---|
|fname|dno|
|John|5|
|John|5|
|Franklin|5|
|Joyce|5|
|Ramesh|5|

The `WHERE` clause can be made more powerful by using logical connectives (`AND`, `OR`, `NOT`) and comparison operators (`<`, `<=`, `>`, `>=`, `=`, `<>`). This allows for the creation of complex, multi-part conditions.

To find employees in department 5 who also have a salary less than $70,000, you can combine conditions with `AND`:

```sql
SELECT fname, salary FROM employee WHERE dno = 5 AND salary < 70000;
```

**Example Output:**

|   |   |
|---|---|
|fname|salary|
|John|30000.00|
|Franklin|40000.00|
|Joyce|25000.00|
|Ramesh|38000.00|

The `WHERE` clause is also where implicit joins across multiple tables are specified. To retrieve details for projects located in 'Stafford', you can join the `PROJECT`, `DEPARTMENT`, and `EMPLOYEE` tables by matching their related keys.

```sql
SELECT Pnumber, Dnum, Lname, Address, Bdate
FROM PROJECT, DEPARTMENT, EMPLOYEE
WHERE Dnum = Dnumber AND Mgr_ssn = Ssn AND Plocation = 'Stafford';
```

**Example Output:**

|   |   |   |   |   |
|---|---|---|---|---|
|Pnumber|Dnum|Lname|Address|Bdate|
|10|4|Wallace|291 Berry, Bellaire, TX|1941-06-20|
|30|4|Wallace|291 Berry, Bellaire, TX|1941-06-20|

### 1.3 Handling Duplicates: The `DISTINCT` Keyword

By default, SQL allows duplicate rows in query results. If a query retrieves multiple identical rows, all of them will be included in the output. The `DISTINCT` keyword is used directly after `SELECT` to eliminate these duplicates and produce a result set containing only unique rows.

To retrieve the unique names and addresses of all employees:

```sql
SELECT DISTINCT Fname, Lname, Address
FROM EMPLOYEE;
```

**Example Output:**

|   |   |   |
|---|---|---|
|Fname|Lname|Address|
|John|Smith|731 Fondren,Houston,TX|
|Franklin|Wong|638 voss,Houston,TX|
|Joyce|English|5631 Rice,Houston,TX|
|Ramesh|Narayan|975 Fire Oak, Humble, TX|
|James|Borg|450 Stone, Houston,TX|
|Jennifer|Wallace|291 Berry, Bellaire,Tx|
|Ahmed|Jabbar|980 Dallas, Houston,TX|
|Alicia|Zelaya|3321 Castle,Spring,TX|

### 1.4 Enhancing Readability and Performing Calculations

SQL queries can do more than just retrieve stored data; they can also perform calculations on the fly and rename columns to make the output clearer and more meaningful.

#### Calculations

The `SELECT` clause can include arithmetic expressions using operators like `+`, `â€“`, `*`, and `/`. For example, to calculate half of each employee's salary:

```sql
SELECT fname, salary/2 FROM EMPLOYEE;
```

**Example Output:**

|   |   |
|---|---|
|fname|salary/2|
|John|15000.000000|
|John|15000.000000|
|Franklin|20000.000000|
|Joyce|12500.000000|
|Ramesh|19000.000000|

#### Renaming

Calculated columns or existing columns can be given a more descriptive name using the `AS` keyword. This enhances the readability of the final report. The `AS` keyword is optional.

```sql
SELECT fname, salary/2 AS monthly_salary
```

To calculate and display the annual salary for each employee under the column name `Annual_Income`:

```sql
SELECT fname, lname, salary*12 AS Annual_Income FROM EMPLOYEE;
```

**Example Output:**

|   |   |   |
|---|---|---|
|fname|lname|Annual_Income|
|John|Smith|360000.00|
|Franklin|Wong|480000.00|
|Joyce|English|300000.00|
|Ramesh|Narayan|456000.00|
|James|Borg|660000.00|
|Jennifer|Wallace|516000.00|
|Ahmed|Jabbar|300000.00|
|Alicia|Zelaya|300000.00|

### 1.5 Pattern Matching: String Comparison with `LIKE`

For filtering based on character data, SQL provides the powerful `LIKE` operator, which enables string matching using pattern wildcards.

There are two special wildcard characters:

- `**percent (%)**`: Matches any substring of zero or more characters.
- `**underscore (_)**`: Matches any single character.

To retrieve all employees whose address is in 'Houston, TX', the `%` wildcard can match any characters before or after the string.

```sql
SELECT Fname, Lname FROM EMPLOYEE WHERE Address LIKE '%Houston,TX%';
```

**Example Output:**

|   |   |
|---|---|
|Fname|Lname|
|John|Smith|
|Franklin|Wong|
|Joyce|English|
|James|Borg|
|Ahmed|Jabbar|

To find all employees born during the 1960s, the `_` wildcard can be used to match any character in the date string after "196".

```sql
SELECT Fname, Lname, bdate FROM EMPLOYEE WHERE Bdate LIKE '196_ _ _ _ _ _ _';
```

**Example Output:**

|   |   |   |
|---|---|---|
|Fname|Lname|bdate|
|John|Smith|1965-01-09|
|Ramesh|Narayan|1962-09-15|
|Ahmed|Jabbar|1969-03-29|
|Alicia|Zelaya|1968-01-19|

**Instructor's Note:** While the `LIKE '196_ _ _ _ _ _ _'` pattern works for fixed-length, character-based date formats, it is not a robust method. A more flexible approach would be `WHERE Bdate LIKE '196%'`, which does not depend on the exact number of characters that follow. For databases that support date functions, a far superior and standards-compliant method would be to use a function like `YEAR(Bdate)` in the condition, such as `WHERE YEAR(Bdate) BETWEEN 1960 AND 1969`.

**Note:** To match a literal percent sign in a string, it must be escaped with a backslash. For example, to find the string "100%", you would use the pattern `'100 \%'`.

### 1.6 Sorting Results: The `ORDER BY` Clause

The `ORDER BY` clause is used to sort the final result set of a query, which is crucial for clear presentation and analysis. It allows you to arrange rows based on the values in one or more columns.

The sorting direction is controlled by two keywords:

- `**ASC**`: Sorts the results in ascending order (A to Z, smallest to largest). This is the default behavior if no direction is specified.
- `**DESC**`: Sorts the results in descending order (Z to A, largest to smallest).

To list employees in descending order of their salary:

```sql
SELECT  fname, lname, salary FROM EMPLOYEE ORDER BY salary DESC;
```

**Example Output:**

|   |   |   |
|---|---|---|
|fname|lname|salary|
|James|Borg|55000.00|
|Jennifer|Wallace|43000.00|
|Franklin|Wong|40000.00|
|Ramesh|Narayan|38000.00|
|John|Smith|30000.00|
|Joyce|English|25000.00|
|Ahmed|Jabbar|25000.00|
|Alicia|Zelaya|25000.00|

To list employees in ascending order of their salary:

```sql
SELECT  fname, lname, salary FROM EMPLOYEE ORDER BY salary ASC;
```

**Example Output:**

|   |   |   |
|---|---|---|
|fname|lname|salary|
|Joyce|English|25000.00|
|Ahmed|Jabbar|25000.00|
|Alicia|Zelaya|25000.00|
|John|Smith|30000.00|
|Ramesh|Narayan|38000.00|
|Franklin|Wong|40000.00|
|Jennifer|Wallace|43000.00|
|James|Borg|55000.00|

With the structure of a single query established, we can now explore how to combine data from multiple tables and multiple query results.

## 2.0 Combining Data Across Tables: An In-Depth Look at JOINs

While a single query can retrieve data from one or more tables, `JOIN` operations are the essential mechanism for creating meaningful, unified datasets by explicitly combining related information from different tables. Previously, we saw an implicit join performed in the `WHERE` clause. Here, we will explore more explicit and powerful `JOIN` syntax, which is the modern standard for combining tables. These operations work by matching rows based on common column values, allowing you to build a comprehensive view from normalized data.

**Note:** To illustrate various join operations, we will now introduce a new set of example tables: `employee`/`department` and `loan`/`borrower`/`cust_info`. Pay close attention to the column names in these new schemas.

This section will cover the primary join types: `NATURAL JOIN`, `INNER JOIN`, `OUTER JOIN` (Left, Right, and Full), and `CROSS JOIN`.

### 2.1 The Implicit Join: `NATURAL JOIN`

A `NATURAL JOIN` creates an implicit join by automatically combining tables based on all columns that share the same name and datatype. It simplifies query syntax when the database schema follows a consistent naming convention for foreign keys.

Key characteristics include:

- No `ON` clause is used to specify the join condition; it is inferred from matching column names.
- The matching join columns appear only once in the final result set.
- It is possible to perform a natural join on more than two tables.

To list employees with their department names, `NATURAL JOIN` can be used, which implicitly joins the tables on their common `Employee_ID` column.

```sql
SELECT employee_name, employee_salary, Department_name
FROM employee NATURAL JOIN Department;
```

**Example Output:**

|   |   |   |
|---|---|---|
|employee_name|employee_salary|Department_name|
|Arun Tiwari|50000|Production|
|Harshal Pathak|48000|Sales|
|Arjun Kuwar|46000|Marketing|
|Sarthak Gada|62000|Accounts|
|Shubham Singh|29000|Development|
|Vicky Gujral|39000|HR|
|Vijay Bose|28000|Sales|

A more complex example can join three tables (`Borrower`, `loan`, `cust_info`) to produce a comprehensive customer loan report.

```sql
SELECT CustName, CustID, amount, mobile, address
FROM Borrower NATURAL JOIN loan NATURAL JOIN cust_info;
```

**Example Output:**

|   |   |   |   |   |
|---|---|---|---|---|
|CustName|CustID|amount|mobile|address|
|Sonakshi Dixit|1|15000|598675498654|777 Brockton Avenue, Abington MA 251|
|Shital Garg|2|100000|698853747888|337 Russell St, Hadley MA 103|
|Swara Joshi|3|150000|234456977555|20 Soojian Dr, Leicester MA 154|
|Isha Deshmukh|4|10000|987656789666|780 Lynnway, Lynn MA 19|
|Swati Bose|5|35000|756489372222|700 Oak Street, Brockton MA 23|

### 2.2 The Workhorse of Joins: `INNER JOIN` (Equijoin)

The `INNER JOIN` is the most frequently used join type. It returns only the rows from each table that satisfy the specified join predicate in the `ON` clause. If a row in one table does not have a corresponding match in the other table, it is excluded from the result set. Conceptually, an `INNER JOIN` returns only the intersecting area between two tables.

The keyword `JOIN` by itself is synonymous with `INNER JOIN`, as it is the default join type in SQL.

**Example 1: Joining** `**employee**` **and** `**department**` **Tables**

This query joins the `employee` and `department` tables where the `Employee_ID` matches.

```sql
SELECT e.Employee_ID, e.Employee_Name, e.Employee_Salary, d.DepartmentID, d.Department_Name 
FROM employee e INNER JOIN department d ON e.Employee_ID = d.Employee_ID;
```

**Example Output:**

|   |   |   |   |   |
|---|---|---|---|---|
|Employee_ID|Employee_Name|Employee_Salary|DepartmentID|Department_Name|
|1|Arun Tiwari|50000|1|Production|
|3|Harshal Pathak|48000|2|Sales|
|4|Arjun Kuwar|46000|3|Marketing|
|5|Sarthak Gada|62000|4|Accounts|
|7|Shubham Singh|29000|5|Development|
|9|Vicky Gujral|39000|6|HR|
|10|Vijay Bose|28000|7|Sales|

**Example 2: Joining** `**Loan**` **and** `**Borrower**` **Tables**

This query joins the `Loan` and `Borrower` tables on their common `Loan_ID` column.

```sql
SELECT l.Loan_ID, l.Branch, l.Amount, b.CustID, b.CustName 
FROM Loan l JOIN Borrower b ON l.Loan_ID = b.Loan_ID;
```

**Example Output:**

|   |   |   |   |   |
|---|---|---|---|---|
|Loan_ID|Branch|Amount|CustID|CustName|
|1|B1|15000|1|Sonakshi Dixit|
|4|B4|100000|2|Shital Garg|
|5|B5|150000|3|Swara Joshi|
|2|B2|10000|4|Isha Deshmukh|
|7|B7|35000|5|Swati Bose|

### 2.3 Preserving Information: `OUTER JOIN` Operations

`OUTER JOIN` is an extension of `INNER JOIN` designed to prevent the loss of information. While an `INNER JOIN` excludes rows that don't have a match, an `OUTER JOIN` includes them, filling in the columns from the non-matching table with `NULL` values. This is essential for analyses where you need to see all records from one or both tables, regardless of whether a relationship exists.

#### 2.3.1 `LEFT OUTER JOIN`

A `LEFT OUTER JOIN` (or `LEFT JOIN`) returns _all_ rows from the left table and only the matched rows from the right table. For any row in the left table that does not have a match in the right table, the columns from the right table will contain `NULL` values. A `LEFT JOIN` includes the entire left table and the overlapping portion of the right table.

**Example 1:** `**employee**` **LEFT JOIN** `**department**`

This query returns all employees, and for those who have a department, it includes department details. Employees without a department will show `NULL` for `DepartmentID` and `Department_Name`.

```sql
SELECT e.Employee_ID, e.Employee_Name, e.Employee_Salary, d.DepartmentID, d.Department_Name 
FROM employee e LEFT OUTER JOIN department d ON e.Employee_ID = d.Employee_ID;
```

**Example Output:**

|   |   |   |   |   |
|---|---|---|---|---|
|Employee_ID|Employee_Name|Employee_Salary|DepartmentID|Department_Name|
|1|Arun Tiwari|50000|1|Production|
|2|Sachin Rathi|64000|NULL|NULL|
|3|Harshal Pathak|48000|2|Sales|
|4|Arjun Kuwar|46000|3|Marketing|
|5|Sarthak Gada|62000|4|Accounts|
|6|Saurabh Sheik|53000|NULL|NULL|
|7|Shubham Singh|29000|5|Development|
|8|Shivam Dixit|54000|NULL|NULL|
|9|Vicky Gujral|39000|6|HR|
|10|Vijay Bose|28000|7|Sales|

**Example 2:** `**Loan**` **LEFT JOIN** `**Borrower**`

This query retrieves all loans, including those not currently assigned to a borrower.

```sql
SELECT L.Loan_ID, L.Branch, L.Amount, B.CustID, B.CustName 
FROM Loan L LEFT OUTER JOIN Borrower B ON L.Loan_ID = B.Loan_ID;
```

**Example Output:**

|   |   |   |   |   |
|---|---|---|---|---|
|Loan_ID|Branch|Amount|CustID|CustName|
|1|B1|15000|1|Sonakshi Dixit|
|2|B2|10000|4|Isha Deshmukh|
|3|B3|20000|NULL|NULL|
|4|B4|100000|2|Shital Garg|
|5|B5|150000|3|Swara Joshi|
|6|B6|50000|NULL|NULL|
|7|B7|35000|5|Swati Bose|
|8|B8|85000|NULL|NULL|

#### 2.3.2 `RIGHT OUTER JOIN`

A `RIGHT OUTER JOIN` (or `RIGHT JOIN`) is the logical inverse of a `LEFT JOIN`. It returns _all_ rows from the right table and only the matched rows from the left table. Any rows from the right table without a match in the left will have `NULL` values for the left table's columns. A `RIGHT JOIN` includes the entire right table and the overlapping portion of the left table.

**Example 1:** `**employee**` **RIGHT JOIN** `**department**`

This query returns all departments, including their employee details if a match is found. Any department without an assigned employee will still be listed, with `NULL`s in the employee columns.

```sql
SELECT e.Employee_ID, e.Employee_Name, e.Employee_Salary, d.DepartmentID, d.Department_Name 
FROM employee e RIGHT OUTER JOIN department d ON e.Employee_ID = d.Employee_ID;
```

**Example Output:**

|   |   |   |   |   |
|---|---|---|---|---|
|Employee_ID|Employee_Name|Employee_Salary|DepartmentID|Department_Name|
|1|Arun Tiwari|50000|1|Production|
|3|Harshal Pathak|48000|2|Sales|
|4|Arjun Kuwar|46000|3|Marketing|
|5|Sarthak Gada|62000|4|Accounts|
|7|Shubham Singh|29000|5|Development|
|9|Vicky Gujral|39000|6|HR|
|10|Vijay Bose|28000|7|Sales|
|NULL|NULL|NULL|8|Legal|

**Example 2:** `**Loan**` **RIGHT JOIN** `**Borrower**`

This query retrieves all borrowers, including those who may not have an active loan in the `Loan` table.

```sql
SELECT l.Loan_ID, l.Branch, l.Amount, b.CustID, b.CustName
FROM Loan l RIGHT OUTER JOIN Borrower b ON l.Loan_ID = b.Loan_ID;
```

**Example Output:**

|   |   |   |   |   |
|---|---|---|---|---|
|Loan_ID|Branch|Amount|CustID|CustName|
|1|B1|15000|1|Sonakshi Dixit|
|4|B4|100000|2|Shital Garg|
|5|B5|150000|3|Swara Joshi|
|2|B2|10000|4|Isha Deshmukh|
|7|B7|35000|5|Swati Bose|
|NULL|NULL|NULL|6|Asha Kapoor|
|NULL|NULL|NULL|7|Nandini Shah|

#### 2.3.3 `FULL OUTER JOIN`

A `FULL OUTER JOIN` combines the results of both `LEFT` and `RIGHT` joins, returning all rows from both tables. If a row in one table does not have a match in the other, the columns from the other table will be `NULL`. It effectively includes all rows from both tables, matched or not.

While some database systems support the `FULL OUTER JOIN` syntax directly, **MySQL does not**. The standard workaround is to combine a `LEFT JOIN` and a `RIGHT JOIN` using the `UNION` operator.

**Example 1: Simulating** `**FULL OUTER JOIN**` **for** `**employee**` **and** `**department**`

```sql
SELECT e.Employee_ID, e.Employee_Name, e.Employee_Salary, d.DepartmentID, d.Department_Name 
FROM department d LEFT OUTER JOIN employee e ON e.Employee_ID = d.Employee_ID 
UNION 
SELECT e.Employee_ID, e.Employee_Name, e.Employee_Salary, d.DepartmentID, d.Department_Name 
FROM department d RIGHT OUTER JOIN employee e ON e.Employee_ID = d.Employee_ID;
```

**Example Output:**

|   |   |   |   |   |
|---|---|---|---|---|
|Employee_ID|Employee_Name|Employee_Salary|DepartmentID|Department_Name|
|1|Arun Tiwari|50000|1|Production|
|3|Harshal Pathak|48000|2|Sales|
|4|Arjun Kuwar|46000|3|Marketing|
|5|Sarthak Gada|62000|4|Accounts|
|7|Shubham Singh|29000|5|Development|
|9|Vicky Gujral|39000|6|HR|
|10|Vijay Bose|28000|7|Sales|
|2|Sachin Rathi|64000|NULL|NULL|
|6|Saurabh Sheik|53000|NULL|NULL|
|8|Shivam Dixit|54000|NULL|NULL|

**Example 2: Simulating** `**FULL OUTER JOIN**` **for** `**Loan**` **and** `**Borrower**`

```sql
SELECT l.Loan_ID, l.Branch, l.Amount, b.CustID, b.CustName 
FROM Loan l LEFT OUTER JOIN Borrower b ON l.Loan_ID = b.Loan_ID 
UNION 
SELECT l.Loan_ID, l.Branch, l.Amount, b.CustID, b.CustName 
FROM Loan l RIGHT OUTER JOIN Borrower b ON l.Loan_ID = b.Loan_ID;
```

**Example Output:**

|   |   |   |   |   |
|---|---|---|---|---|
|Loan_ID|Branch|Amount|CustID|CustName|
|1|B1|15000|1|Sonakshi Dixit|
|2|B2|10000|4|Isha Deshmukh|
|3|B3|20000|NULL|NULL|
|4|B4|100000|2|Shital Garg|
|5|B5|150000|3|Swara Joshi|
|6|B6|50000|NULL|NULL|
|7|B7|35000|5|Swati Bose|
|8|B8|85000|NULL|NULL|
|NULL|NULL|NULL|6|Asha Kapoor|
|NULL|NULL|NULL|7|Nandini Shah|

### 2.4 The Cartesian Product: `CROSS JOIN`

A `CROSS JOIN` returns the Cartesian product of two tables. This means that every row from the first table is combined with every row from the second table. This join type does not use an `ON` clause or any join condition. The total number of rows in the result set is the number of rows in the first table multiplied by the number of rows in the second.

For example, performing a `CROSS JOIN` on the `loan` table (8 rows) and the `borrower` table (7 rows) will produce a result set with 8 * 7 = 56 rows.

```sql
SELECT * FROM loan CROSS JOIN borrower;
```

This operation is used less frequently but can be valuable for generating all possible combinations of records between two tables for certain types of analysis. Having explored how to combine tables horizontally through joins, the next step is to understand how to combine the results of entire queries vertically using set operators.

## 3.0 Manipulating Result Sets: SQL Set Operators

While `JOIN` operations combine tables horizontally based on column relationships, SQL set operators work differently. They combine the _row results_ of two or more `SELECT` statements in a manner similar to mathematical set theory, allowing you to merge, intersect, or find differences between result sets.

A critical prerequisite for using any set operator is that the `SELECT` statements being combined must return the same number of columns, and the corresponding columns must have compatible data types.

### 3.1 Combining Sets: `UNION` and `UNION ALL`

#### `UNION`

The `UNION` operator combines the result sets of two or more `SELECT` statements and automatically eliminates any duplicate rows from the final result.

To find the unique set of grades awarded in both 'Physics' and 'Mathematics' courses:

```sql
SELECT grade FROM student_course WHERE course = 'Physics'
UNION
SELECT grade FROM student_course WHERE course = 'Mathematics';
```

**Example Output (Duplicates Removed):**

|   |
|---|
|grade|
|S|
|A|
|B|

#### `UNION ALL`

The `UNION ALL` operator also combines result sets but _includes all duplicate rows_. It is generally more performant than `UNION` because it does not incur the overhead of checking for and removing duplicates. If a value appears `c1` times in the first result and `c2` times in the second, it will appear `c1 + c2` times in the final output.

To find all grades awarded across 'Physics' and 'Mathematics', including duplicates:

```sql
SELECT grade FROM student_course WHERE course = 'Physics'
UNION ALL
SELECT grade FROM student_course WHERE course = 'Mathematics';
```

**Example Output (Duplicates Included):**

|   |
|---|
|grade|
|S|
|S|
|A|
|B|
|B|
|S|
|S|
|A|
|A|
|A|

### 3.2 Finding Commonalities: `INTERSECT` and `INTERSECT ALL`

#### `INTERSECT`

The `INTERSECT` operator returns only the rows that are present in both `SELECT` statements. It effectively finds the commonality, or intersection, between two result sets, and like `UNION`, it removes duplicate rows.

To find the grades that were awarded in _both_ 'Physics' and 'Mathematics':

```sql
SELECT grade FROM student_course WHERE course = 'Physics'
INTERSECT
SELECT grade FROM student_course WHERE course = 'Mathematics';
```

**Example Output:**

|   |
|---|
|grade|
|S|
|A|

#### `INTERSECT ALL`

The `INTERSECT ALL` operator also finds the common rows between two result sets but retains duplicates. If a row appears `c1` times in the first result and `c2` times in the second, it will appear `min(c1, c2)` times in the final output.

For example, the grade 'S' appears twice in Physics and twice in Mathematics, so `min(2, 2) = 2` occurrences are returned. The grade 'A' appears once in Physics and three times in Mathematics, so `min(1, 3) = 1` occurrence is returned.

```sql
SELECT grade FROM student_course WHERE course = 'Physics'
INTERSECT ALL
SELECT grade FROM student_course WHERE course = 'Mathematics';
```

**Example Output:**

|   |
|---|
|grade|
|S|
|S|
|A|

### 3.3 Finding Differences: `EXCEPT` and `EXCEPT ALL`

#### `EXCEPT`

The `EXCEPT` operator (known as `MINUS` in some SQL dialects) returns all unique rows from the first `SELECT` statement that are _not_ present in the second `SELECT` statement. The order of the queries is critical for this operation.

To find the grades that were awarded in 'Physics' but not in 'Mathematics':

```sql
SELECT grade FROM student_course WHERE course = 'Physics'
EXCEPT
SELECT grade FROM student_course WHERE course = 'Mathematics';
```

**Example Output:**

|   |
|---|
|grade|
|B|

Conversely, to find grades awarded in 'Mathematics' but not in 'Physics', the query returns an empty set, as 'S' and 'A' are both present in the Physics results.

```sql
SELECT grade FROM student_course WHERE course = 'Mathematics'
EXCEPT
SELECT grade FROM student_course WHERE course = 'Physics';
```

**Example Output:**

|   |
|---|
|grade|

#### `EXCEPT ALL`

The `EXCEPT ALL` operator performs the same subtraction but accounts for duplicates. If a row appears `c1` times in the first result and `c2` times in the second, it will appear `max(c1 - c2, 0)` times in the final output.

To find the grades from 'Physics' that are not in 'Mathematics', accounting for duplicates: The grade 'B' appears twice in Physics and zero times in Mathematics, so `max(2 - 0, 0) = 2` occurrences are returned.

```sql
SELECT grade FROM student_course WHERE course = 'Physics'
EXCEPT ALL
SELECT grade FROM student_course WHERE course = 'Mathematics';
```

**Example Output:**

|   |
|---|
|grade|
|B|
|B|

To find grades from 'Mathematics' not in 'Physics': The grade 'A' appears three times in Mathematics and once in Physics, so `max(3 - 1, 0) = 2` occurrences are returned. 'S' appears twice in both, so `max(2 - 2, 0) = 0` are returned.

```sql
SELECT grade FROM student_course WHERE course = 'Mathematics' 
EXCEPT ALL 
SELECT grade FROM student_course WHERE course = 'Physics';
```

**Example Output:**

|   |
|---|
|grade|
|A|
|A|

After mastering how to combine valid data from different queries, it's essential to address the special case of how SQL handles missing or unknown data, represented by `NULL`.

## 4.0 The Challenge of `NULL`: Handling Missing and Unknown Data

In SQL, understanding how to handle `NULL` is critically important for accurate data analysis. `NULL` is not a value in the same way that `0` or an empty string is a value. Instead, it is a special marker used to indicate that data is unknown, unavailable, or inapplicable for a particular record. This unique nature means `NULL` behaves differently from other values in calculations, comparisons, and filtering, requiring specific operators and a distinct logical framework.

### 4.1 The Three Meanings of `NULL`

Conceptually, a `NULL` marker can represent one of three situations:

1. **Unknown value:** The value exists but is not known at this time (e.g., an employee's date of birth has not been recorded yet).
2. **Unavailable or withheld value:** The value exists, but it is purposely not being disclosed (e.g., an individual chooses not to provide their phone number).
3. **Not applicable attribute:** The attribute itself does not apply to the specific row (e.g., the `LastCollegeDegree` attribute for a person who has never attended college).

It is important to note that while these meanings are distinct conceptually, SQL does not differentiate between them in its implementation. All `NULL`s are treated the same way by the database engine.

### 4.2 `NULL` in Operations and Comparisons

The special status of `NULL` becomes most apparent when it is used in arithmetic or comparison operations.

#### Arithmetic Operations

The rule for arithmetic is straightforward: any arithmetic operation (`+`, `-`, `*`, `/`) involving a `NULL` value as an operand results in `NULL`. This propagates the "unknown" nature of the data. If you add 10 to an unknown number of hours, the result is still an unknown number of hours.

**Example of** `**NULL**` **Propagation:**

|   |   |
|---|---|
|Hours|Hours+10|
|32.5|42.5|
|7.5|17.5|
|10.0|20.0|
|...|...|
|**NULL**|**NULL**|
|15.0|25.0|
|20.0|30.0|

#### Comparison Operations and Three-Valued Logic

Comparisons involving `NULL` are more complex. Because `NULL` represents an unknown, a comparison like `NULL = 5` or `NULL = NULL` cannot be definitively evaluated as `TRUE` or `FALSE`. Instead, SQL introduces a third logical value: `UNKNOWN`.

This leads to a three-valued logic system that governs how conditions are evaluated:

- `**AND**`: The result is `TRUE` only if both operands are `TRUE`. It is `FALSE` if either operand is `FALSE`. Otherwise, it is `UNKNOWN`.
- `**OR**`: The result is `TRUE` if either operand is `TRUE`. It is `FALSE` only if both operands are `FALSE`. Otherwise, it is `UNKNOWN`.
- `**NOT**`: `NOT TRUE` is `FALSE`, `NOT FALSE` is `TRUE`, and `NOT UNKNOWN` is `UNKNOWN`.

The most critical rule for data retrieval is how the `WHERE` clause handles this logic: **the** `**WHERE**` **clause only includes rows where the final predicate evaluates to** `**TRUE**`. Rows that evaluate to `FALSE` or `UNKNOWN` are excluded from the result set.

### 4.3 Correctly Testing for `NULL`

Because a comparison like `Super_ssn = NULL` evaluates to `UNKNOWN`, it can never be used to find rows where a value is `NULL`. SQL provides a special set of operators for this specific purpose.

- `**IS NULL**`: Tests if a value is `NULL`.
- `**IS NOT NULL**`: Tests if a value is not `NULL`.

To retrieve the names of all employees who do not have supervisors (i.e., their `Super_ssn` is `NULL`):

```sql
SELECT Fname, Lname FROM EMPLOYEE WHERE Super_ssn IS NULL;
```

**Example Output:**

|   |   |
|---|---|
|Fname|Lname|
|James|Borg|

Additionally, SQL provides less common clauses to test the outcome of a comparison directly: `IS UNKNOWN` and `IS NOT UNKNOWN`. These are useful for finding rows where a condition could not be resolved to `TRUE` or `FALSE` due to a `NULL` value.

For example, the condition `Hours > 10` will evaluate to `UNKNOWN` only for rows where `Hours` is `NULL`.

```sql
SELECT Essn, Pno FROM WORKS_ON WHERE Hours > 10 IS UNKNOWN;
```

**Example Output:**

|   |   |
|---|---|
|Essn|Pno|
|888665555|20|

### 4.4 `NULL` in Set and `DISTINCT` Operations

`NULL` exhibits a unique and important behavior when used with operations that identify duplicates, such as `DISTINCT`, `UNION`, `INTERSECT`, and `EXCEPT`.

The key distinction is: **for the purpose of grouping and eliminating duplicates, two** `**NULL**` **values are considered identical.**

For example, if a `SELECT DISTINCT` query encounters two rows like `('A', NULL)` and `('A', NULL)`, it will treat them as duplicates and only one will be retained in the final result. This is a pragmatic choice to make these operations behave as users would intuitively expect.

This behavior stands in sharp contrast to how `NULL` is treated in a `WHERE` clause predicate, where the comparison `NULL = NULL` evaluates to `UNKNOWN`. This duality is a critical concept to grasp for correct and predictable SQL querying.

## 5.0 Conclusion

Mastering SQL is a journey from simple data retrieval to complex data manipulation and analysis. This guide has covered the essential pillars of that journey: structuring a foundational query with `SELECT`, `FROM`, and `WHERE`; combining data horizontally across tables using a variety of `JOIN` operations; merging results vertically with set operators like `UNION` and `INTERSECT`; and navigating the logical challenges of handling `NULL` values. A firm grasp of these core concepts provides the comprehensive skill set needed to transform raw data into powerful, actionable insights and sophisticated reports.