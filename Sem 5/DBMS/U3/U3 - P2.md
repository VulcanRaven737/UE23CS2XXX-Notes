# A Comprehensive Guide to Functional Dependencies: Equivalence, Minimal Cover, and Candidate Keys

## 1.0 Equivalence of Functional Dependencies

In the design of relational databases, functional dependencies (FDs) serve as the fundamental rules that govern the relationships between attributes. The concept of equivalence between two sets of functional dependencies is of strategic importance. It allows database designers to compare different schema designs, simplify complex sets of rules, and optimize the database structure without losing any logical integrity. Understanding equivalence ensures that two different-looking sets of FDs can be recognized as enforcing the exact same data constraints.

This understanding provides the foundation for determining if one set of FDs can be logically derived from another, a concept known as covering, which is the cornerstone of equivalence.

### 1.1 Core Definitions: Covering and Equivalence

The ability of one set of functional dependencies to imply another is formally defined as "covering."

A set of functional dependencies F is said to cover another set of functional dependencies E if every FD in E is also in F+; that is, if every dependency in E can be inferred from F; alternatively, we can say that E is covered by F.

With this definition, we can establish what it means for two sets to be equivalent. Equivalence is a two-way street: each set must be able to cover the other.

Two sets of functional dependencies E and F are equivalent if E+ = F+. Equivalence means that every FD in E can be inferred from F, and every FD in F can be inferred from E; that is, E is equivalent to F if both the conditions—E covers F and F covers E—hold.

In essence, two sets of FDs are equivalent if they produce the same closure, meaning they logically enforce the identical set of constraints on the data, even if their written forms differ.

### 1.2 The Process for Determining Equivalence

To determine if two sets of functional dependencies, `F` and `G`, are equivalent, a systematic process is followed. This process involves checking if each set covers the other.

1. **Check if F covers G.**
    - For each functional dependency `X → Y` in the set `G`, calculate the attribute closure of its left-hand side, `X+`, using only the dependencies available in set `F`.
    - If the resulting closure `X+` contains all attributes from `Y`, then the dependency `X → Y` is covered by `F`.
    - If this holds true for all dependencies in `G`, then `F` covers `G`.
2. **Check if G covers F.**
    - For each functional dependency `X → Y` in the set `F`, calculate the attribute closure of its left-hand side, `X+`, using only the dependencies available in set `G`.
    - If the resulting closure `X+` contains all attributes from `Y`, then the dependency `X → Y` is covered by `G`.
    - If this holds true for all dependencies in `F`, then `G` covers `F`.
3. **Determine Equivalence.**
    - If both `F` covers `G` and `G` covers `F`, the two sets are equivalent (`F = G`).

### 1.3 Worked Example: Verifying Equivalence

Let's apply this process to a concrete example. Consider the following two sets of functional dependencies:

- `F = {A → C, AC → D, E → AD, E → H}`
- `G = {A → CD, E → AH}`

We will now determine if these two sets are equivalent.

#### **Step A: Does F Cover G?**

We must check if each dependency in `G` can be derived from `F`.

1. **Check** `**A → CD**` **from G:**
    - We calculate the closure of `A` using the dependencies in `F`.
    - `(A)+` with respect to F:
        - Start with `{A}`.
        - Using `A → C`, the set becomes `{A, C}`.
        - Using `AC → D` (since we now have both `A` and `C`), the set becomes `{A, C, D}`.
    - Since `{A, C, D}` contains `CD`, the dependency `A → CD` is covered by F.
2. **Check** `**E → AH**` **from G:**
    - We calculate the closure of `E` using the dependencies in `F`.
    - `(E)+` with respect to F:
        - Start with `{E}`.
        - Using `E → AD`, the set becomes `{E, A, D}`.
        - Using `E → H`, the set becomes `{E, A, D, H}`.
        - Using `A → C` (since `A` is now in our set), the final set becomes `{A, C, D, E, H}`.
    - Since `{A, C, D, E, H}` contains `AH`, the dependency `E → AH` is covered by F.

**Conclusion for Step A:** Since all dependencies in `G` can be derived from `F`, we conclude that **F covers G**.

#### **Step B: Does G Cover F?**

Next, we must check if each dependency in `F` can be derived from `G`.

1. **Check** `**A → C**` **from F:**
    - We calculate the closure of `A` using the dependencies in `G`.
    - `(A)+` with respect to G:
        - Start with `{A}`.
        - Using `A → CD`, the set becomes `{A, C, D}`.
    - Since `{A, C, D}` contains `C`, the dependency `A → C` is covered by G.
2. **Check** `**AC → D**` **from F:**
    - We calculate the closure of `AC` using the dependencies in `G`.
    - `(AC)+` with respect to G:
        - Start with `{A, C}`.
        - Using `A → CD`, the set becomes `{A, C, D}`.
    - Since `{A, C, D}` contains `D`, the dependency `AC → D` is covered by G.
3. **Check** `**E → AD**` **and** `**E → H**` **from F:**
    - We calculate the closure of `E` using the dependencies in `G`.
    - `(E)+` with respect to G:
        - Start with `{E}`.
        - Using `E → AH`, the set becomes `{E, A, H}`.
        - Using `A → CD` (since `A` is now in our set), the final set becomes `{A, C, D, E, H}`.
    - Since `{A, C, D, E, H}` contains both `AD` and `H`, the dependencies `E → AD` and `E → H` are covered by G.

**Conclusion for Step B:** Since all dependencies in `F` can be derived from `G`, we conclude that **G covers F**.

#### **Final Conclusion**

Because F covers G and G covers F, the two sets are equivalent (`F = G`). This example demonstrates that sets of dependencies with different structures can enforce the same logical constraints. This principle naturally leads to the question of simplification: can we find the simplest, most compact set of dependencies that is equivalent to a given set? This simplified form is known as a minimal cover.

## 2.0 Minimal Cover of Functional Dependencies

Finding a minimal cover is an essential "housekeeping" task for managing functional dependencies. It is the process of reducing a set of data rules to its simplest, non-redundant form while ensuring it remains fully equivalent to the original set. A minimal cover contains no redundant dependencies or extraneous attributes, making it the most efficient representation of the underlying data constraints. This simplification is critical for database normalization and for creating a clear and maintainable database schema.

### 2.1 Defining a Minimal Set

A set of functional dependencies `F` is considered minimal if it satisfies three specific conditions:

1. Every dependency in `F` has a single attribute on its right-hand side (RHS). This is also known as the canonical form.
2. No dependency `X → A` in `F` can be replaced by a dependency `Y → A`, where `Y` is a proper subset of `X`, without changing the logical closure. This means there are no **extraneous attributes** on the left-hand side (LHS) of any dependency. An attribute is extraneous if it can be removed from the LHS of an FD without affecting the set's closure.
3. No dependency can be removed from `F` without changing its logical closure. This ensures there are no redundant dependencies that can be inferred from the others in the set.

### 2.2 Algorithm for Finding a Minimal Cover

A formal algorithm can be used to compute the minimal cover `F` for a given set of functional dependencies `E`.

1. Initialize a new set `F` to be equal to the input set `E`.
2. Replace each functional dependency in `F` of the form `X → {A1, A2, ..., An}` with `n` separate dependencies: `X → A1`, `X → A2`, ..., `X → An`. This converts the set into its canonical form.
3. For each functional dependency `X → A` in `F`, and for each attribute `B` in `X`, check if `B` is an extraneous attribute. If removing `B` from `X` results in a set that is still equivalent to the original `F`, then replace `X → A` with `(X – {B}) → A`. Repeat this until no extraneous attributes remain in any dependency.
4. For each remaining functional dependency `X → A` in `F`, check if it is redundant. If removing the entire dependency `X → A` from `F` results in a set that is still equivalent to the original `F`, then remove it permanently.

### 2.3 Worked Example 1: A Straightforward Reduction

Let's find the minimal cover for the set `E: {B → A, D → A, AB → D}`.

- **Step 1: Canonical Form.** The set is already in canonical form, as each dependency has a single attribute on its RHS.
- **Step 2: Remove Extraneous Attributes.** We analyze the dependency `AB → D` to see if either `A` or `B` is extraneous on the LHS.
    - We analyze `AB → D`. To check if `A` is extraneous, we need to see if `B → D` can be inferred from the original set `E: {B → A, D → A, AB → D}`.
    - Since `B → A` is given in the set `E`, we know that any time we have `B`, we also have `A`. Therefore, the attribute `A` in the `AB → D` dependency is redundant because it is already determined by `B`. This simplifies `AB → D` to `B → D`.
    - The updated set is `E′ : {B → A, D → A, B → D}`.
- **Step 3: Remove Redundant Dependencies.** We now analyze the set `E′` for any redundant dependencies.
    - Consider the dependency `B → A`. Can it be derived from the other dependencies in `E′`, which are `{D → A, B → D}`?
    - Using the transitive rule on `B → D` and `D → A`, we can derive `B → A`.
    - Therefore, `B → A` is a redundant dependency and can be removed.
- **Conclusion.** The final minimal cover is `**F: {B → D, D → A}**`.

### 2.4 An Alternative Method and Detailed Example

For more complex problems, an alternative three-step method provides a more structured approach to finding a minimal cover.

- **Step 1: Decompose Right-Hand Side (RHS)** Ensure every functional dependency has only a single attribute on its RHS. For any dependency like `A → BC`, split it into `A → B` and `A → C`.
- **Step 2: Remove Redundant Functional Dependencies** For each dependency `X → A`, temporarily remove it and calculate the closure of `X` using the remaining dependencies. If `A` is in the closure, the dependency is redundant and can be permanently removed.
- **Step 3: Remove Extraneous Attributes from Left-Hand Side (LHS)** For each dependency `X → A` where `X` has more than one attribute, check each attribute `Y` in `X`. Temporarily remove `Y` from `X` to get `X'`. Calculate the closure of `X'`. If `A` is in the closure of `X'`, then `Y` is an extraneous attribute. Replace the original dependency with `X' → A`.

#### Applying the Method

Let's apply this method to find the minimal cover for the set: `{A → C, AB → C, C → DI, CD → I, EC → AB, EI → C}`.

**Step 1: Decompose RHS**

We decompose dependencies with multiple attributes on the RHS (`C → DI` and `EC → AB`) into their canonical form.

The initial set `FD` is: `{A → C, AB → C, C → D, C → I, CD → I, EC → A, EC → B, EI → C}`

**Step 2: Remove Redundant Functional Dependencies**

We check each dependency in `FD` for redundancy.

- a. `A → C`: Check `A+` without `A→C`. `A+ = {A}`. `C` is not in the closure, so `A → C` is **not redundant**.
- b. `AB → C`: Check `(AB)+` without `AB→C`. We use the remaining FDs: `{A → C, C → D, ...}`. `(AB)+` starts with `{A, B}`. Using `A → C`, we get `{A, B, C}`. Since `C` is in the closure, `AB → C` is **redundant**.
    - The updated set is `FD1 = {A → C, C → D, C → I, CD → I, EC → A, EC → B, EI → C}`.
- c. `C → D`: Check `C+` using `FD1` but without `C→D`. `C+` starts with `{C}`. Using `C → I`, we get `{C, I}`. `D` is not in the closure, so `C → D` is **not redundant**.
- d. `C → I`: Check `C+` using `FD1` but without `C→I`. `C+` starts with `{C}`. Using `C → D`, we get `{C, D}`. Using `CD → I`, we get `{C, D, I}`. Since `I` is in the closure, `C → I` is **redundant**.
    - The updated set is `FD2 = {A → C, C → D, CD → I, EC → A, EC → B, EI → C}`.
- e. `EC → A`: Check `(EC)+` using `FD2` but without `EC→A`. `(EC)+ = {E, C}`. Using `C→D`, we get `{E, C, D}`. No other rules apply. `A` is not in the closure, so `EC → A` is **not redundant**.
- f. `EC → B`: Check `(EC)+` using `FD2` but without `EC→B`. `(EC)+ = {E, C}`. Using other rules, we get `{E,C,D,I,A}`. `B` is not in the closure, so `EC → B` is **not redundant**.
- g. `CD → I`: Check `(CD)+` using `FD2` but without `CD→I`. `(CD)+ = {C, D}`. No other rules apply. `I` is not in theclosure, so `CD → I` is **not redundant**.
- h. `EI → C`: Check `(EI)+` using `FD2` but without `EI→C`. `(EI)+ = {E, I}`. No other rules apply. `C` is not in the closure, so `EI → C` is **not redundant**.

After this step, the set of dependencies is `FD2 = {A → C, C → D, CD → I, EC → A, EC → B, EI → C}`.

**Step 3: Remove Extraneous Attributes from LHS**

We examine dependencies in `FD2` with more than one attribute on the LHS: `CD → I`, `EC → A`, `EC → B`, `EI → C`.

- a. **Check** `**CD → I**` **from the set** `**FD2 = {A → C, C → D, CD → I, EC → A, EC → B, EI → C}**`**.**
    - **Is** `**D**` **extraneous?** To test this, we remove `D` from the LHS, leaving `C`. We must then check if `I` is in the closure of `{C}` using the full set `FD2`.
        - `C+` with respect to `FD2`:
        - Start with `{C}`.
        - Using `C → D`, the set becomes `{C, D}`.
        - Using `CD → I` (since we now have `C` and `D`), the set becomes `{C, D, I}`.
    - The final closure `{C, D, I}` contains `I`. Therefore, `D` is **extraneous**. We replace `CD → I` with `C → I`.
    - The updated set is `FD3 = {A → C, C → D, C → I, EC → A, EC → B, EI → C}`.
- b. **Check** `**EC → A**` **from** `**FD3**`**:**
    - Is `C` extraneous? Check `E+` using `FD3`. `E+ = {E}`. `A` is not in the closure.
    - Is `E` extraneous? Check `C+` using `FD3`. `C+ = {C, D, I}`. `A` is not in the closure.
    - There are **no extraneous attributes**.
- c. **Check** `**EC → B**` **from** `**FD3**`**:**
    - Is `C` extraneous? Check `E+` using `FD3`. `E+ = {E}`. `B` is not in the closure.
    - Is `E` extraneous? Check `C+` using `FD3`. `C+ = {C, D, I}`. `B` is not in the closure.
    - There are **no extraneous attributes**.
- d. **Check** `**EI → C**` **from** `**FD3**`**:**
    - Is `I` extraneous? Check `E+` using `FD3`. `E+ = {E}`. `C` is not in the closure.
    - Is `E` extraneous? Check `I+` using `FD3`. `I+ = {I}`. `C` is not in the closure.
    - There are **no extraneous attributes**.

The final minimal cover is `**{A → C, C → D, C → I, EC → A, EC → B, EI → C}**`.

Having simplified the set of rules, the next step is to use these rules to identify the keys that uniquely define records in a relation.

## 3.0 Identifying Candidate Keys for a Relation

A candidate key is a fundamental concept in relational databases. It is a minimal set of attributes that uniquely identifies each record in a table. A relation can have multiple candidate keys, and from this set, one is chosen to be the primary key. Identifying candidate keys is crucial for ensuring data integrity, preventing duplicate records, and establishing relationships between tables.

### 3.1 A Method for Finding Candidate Keys

A straightforward two-step process can be used to find the candidate keys for a relation given a set of functional dependencies.

- **Step 1: Identify Essential Attributes.** An **essential attribute** is an attribute that does not appear on the right-hand side (RHS) of any functional dependency. The logic is simple: since an essential attribute cannot be derived from any other attributes in the relation, it _must_ be included in any set of attributes that aims to uniquely identify a record. Therefore, all essential attributes must be part of every candidate key.
- **Step 2: Calculate the Closure.** After identifying the set of all essential attributes, the next step is to calculate the attribute closure of this set. There are two possible outcomes from this calculation:
    - **Case 1:** If the closure of the essential attributes contains all attributes in the relation, then the set of essential attributes is the one and only candidate key.
    - **Case 2:** If the closure does not contain all attributes, the essential attributes alone are insufficient. To form a candidate key, they must be combined with one or more of the non-essential attributes. In this scenario, you must test different combinations of essential and non-essential attributes to find all possible candidate keys.

### 3.2 Worked Example: Finding a Candidate Key

Consider the following relation and its functional dependencies:

- **Relation:** `R = (A, B, C, D, E, F)`
- **Dependencies:** `{C → F, E → A, EC → D, A → B}`

Let's find the candidate key(s) for this relation.

- **Step 1: Find Essential Attributes.** We examine the RHS of each dependency: `F`, `A`, `D`, `B`. The attributes that never appear on the RHS are **C** and **E**. Therefore, `C` and `E` are the essential attributes and must be part of any candidate key.
- **Step 2: Calculate Closure of Essential Attributes.** We calculate the closure of the set of essential attributes, `{CE}`.
    - The initial set for `{CE}+` is `{C, E}`.
    - Using `C → F`, the set becomes `{C, E, F}`.
    - Using `E → A`, the set becomes `{A, C, E, F}`.
    - Using `EC → D` (since we have both `E` and `C`), the set becomes `{A, C, D, E, F}`.
    - Using `A → B` (since we now have `A`), the final set becomes `{A, B, C, D, E, F}`.
- **Conclusion.** The closure `{CE}+` contains all attributes of the relation `R`. This falls under Case 1, which means the set of essential attributes is the candidate key. Therefore, **CE** is the only candidate key for this relation.

### 3.3 From Candidate Keys to Super Keys

Once the candidate key(s) are identified, it is easy to determine the super keys. A **super key** is any set of attributes that contains a candidate key.

Using our worked example, we can calculate the total number of possible super keys:

- The relation `R` has 6 total attributes: `(A, B, C, D, E, F)`.
- The candidate key `CE` is composed of 2 essential attributes.
- This leaves 4 non-essential attributes: `A`, `B`, `D`, `F`.

A super key must contain the candidate key `CE`. Any combination of the 4 non-essential attributes can be added to `CE` to form a valid super key. Since each of the 4 non-essential attributes can either be included or not included (2 choices), the total number of combinations is:

`2 * 2 * 2 * 2 = 2^4 = 16`

There are **16** possible super keys for this relation.

Now that you have learned the core concepts of equivalence, minimal cover, and key identification, you can apply this knowledge to solve a variety of database design problems.

## 4.0 Test Your Knowledge: Practice Problems

The best way to solidify your understanding of these concepts is to apply them. Use the methods described in this guide to solve the following practice problems.

### 4.1 Equivalence Problems

1. Are the following sets of functional dependencies equivalent?
    - `FD1 = {x->y, xy->z, w->xz, w->vy}`
    - `FD2 = {x->yz, w->xv}`
2. Are the following sets of functional dependencies equivalent?
    - `F = {A->B, B->C, A->C}`
    - `G = {A->B, B->C, A->D}`

### 4.2 Minimal Cover Problems

1. Find the minimal cover of the following set of functional dependencies:
    - `G : {v → w, vw→ x, y→ vxz}`
2. Find the minimal cover of the following set of functional dependencies:
    - `G : {A → B, C→ B, D→ ABC, AC→ D}`

### 4.3 Candidate Key Problems

1. For a relation `R = (A, B, C, D, E)` with the dependencies `{AB → C, C → D, B → E}`, determine the total number of candidate keys and super keys.
2. For a relation `R(E, F, G, H, I, J, K, L, M, N)` with the dependencies `{{E, F} → {G}, {F} → {I, J}, {E, H} → {K, L}, {K} → {M}, {L} → {N}}`, determine the total number of candidate keys and super keys.