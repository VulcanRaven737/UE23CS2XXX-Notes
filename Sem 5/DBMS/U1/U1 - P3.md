# A Comprehensive Guide to SQL: Data Definition and Modification

## 1.0 Introduction to SQL and its Core Components

Structured Query Language, or SQL, is the universally accepted standard language for interacting with relational databases and serves as a cornerstone of modern data management. Its power and versatility stem from its organization into several distinct sub-languages, each designed for a specific set of tasks. This guide will focus on the two most fundamental of these: the Data Definition Language (DDL) for creating the database structure, and the Data Manipulation Language (DML) for managing the data held within it.

The history of SQL is a major reason for the commercial success of relational databases. It originated as "SEQUEL," a term used in the seminal paper "SEQUEL TO SQUARE" by Chamberlin and Boyce at IBM. The name was later abbreviated to SQL, now popularly known as "Structured Query Language," and the language has since evolved to include a rich set of features for data definition, manipulation, transaction control, security, and more. To effectively work with databases, it is essential to understand its primary components.

The SQL standard is typically divided into four primary sub-languages:

- **Data Definition Language (DDL):** Used to define the database structure or schema.
- **Data Manipulation Language (DML):** Used for managing data within schema objects.
- **Data Control Language (DCL):** Used to control access to the database.
- **Transaction Control Language (TCL):** Used to manage and finalize the changes made by DML statements within a transaction.

This guide will begin by exploring how to define the very structure of a database using the commands of the Data Definition Language.

## 2.0 Defining the Database Structure: Data Definition Language (DDL)

The commands of the Data Definition Language (DDL) serve as the architectural blueprints for a database. They are used to create, alter, and delete the fundamental database objects—such as tables and schemas—that establish the foundational structure where data will ultimately reside.

At the highest level of organization is the SQL schema, which is a named collection of related database objects. A schema is identified by its name and includes an authorization identifier along with descriptors for each of its elements, such as tables, constraints, views, and domains. In the MySQL database system, the `CREATE SCHEMA` command is functionally equivalent to `CREATE DATABASE`.

### 2.1 Foundational DDL Commands

The DDL provides a core set of commands for managing the lifecycle of database objects.

- `**CREATE**`**:** Used to create new objects in the database, such as tables or schemas.
- `**ALTER**`**:** Used to modify the structure of existing database objects.
- `**DROP**`**:** Used to permanently delete objects from the database.
- `**TRUNCATE**`**:** Used to remove all records from a table, including all the space allocated for those records.
- `**COMMENT**`**:** Used to add comments to the data dictionary, serving as descriptive metadata for database objects.

### 2.2 Building Tables: The `CREATE TABLE` Statement

The `CREATE TABLE` command is the main SQL command for data definition. It is used to create a new table (or _relation_) by specifying its name, its attributes (_columns_), and any initial constraints that must be enforced on the data. Each row of data added to this table is referred to as a _tuple_ in the formal relational model.

The basic syntax for creating a new table is as follows:

```sql
CREATE TABLE table_name (
    Col_name1 datatype(),
    Col_name2 datatype(),
    ...
    Col_namen datatype()
);
```

In addition to creating a new table from scratch, SQL provides two methods for creating a new table based on the structure and content of an existing one. The choice between `CREATE TABLE ... AS SELECT` and `CREATE TABLE ... LIKE` depends on whether you need to copy just the structure or both the structure and the data.

|   |   |   |
|---|---|---|
|Feature|`CREATE TABLE ... AS SELECT`|`CREATE TABLE ... LIKE`|
|**Copies structure**|Yes|Yes|
|**Copies data**|Yes|No|
|**Copies constraints/indexes**|No|Yes|
|**Copies** `**AUTO_INCREMENT**`|No|Yes|
|**Flexibility in copying data**|Yes (can use `WHERE`, `JOIN`)|No|

### 2.3 Defining Columns: A Deep Dive into SQL Data Types

Selecting the correct data type for each attribute in a table is a critical design decision. This choice directly impacts the integrity of the data, the efficiency of data storage, and the performance of queries against the table. An appropriate data type ensures that only valid data is stored and optimizes the database's resource utilization.

#### 2.3.1 Numeric Data Types

- **Integer numbers:** `INTEGER` (or `INT`) is the standard integer type, while `SMALLINT` is used for integers that require less storage space.
- **Floating-point (real) numbers:** `FLOAT` or `REAL` for single-precision floating-point numbers, and `DOUBLE PRECISION` for double-precision numbers.
- **Fixed-point numbers:** `NUMERIC(p, d)` defines a number with a precise number of digits. The precision `p` is the total number of digits, and the scale `d` is the number of digits to the right of the decimal point. For example, `NUMERIC(3,1)` could store `44.5` but not `444.5`.

#### 2.3.2 Character-String Data Types

- **Fixed length:** `CHAR(n)` or `CHARACTER(n)` stores a character string of a fixed length `n`.
- **Varying length:** `VARCHAR(n)`, `CHAR VARYING(n)`, or `CHARACTER VARYING(n)` stores a character string with a variable length up to a maximum of `n` characters.
- `**ENUM**`**:** A MySQL-specific string object that constrains a column's value to a predefined list of permitted values specified during table creation. This is an effective way to enforce a controlled vocabulary for an attribute.

#### 2.3.3 A Practical Comparison: `CHAR` vs. `VARCHAR`

The choice between fixed-length (`CHAR`) and variable-length (`VARCHAR`) strings depends on the nature of the data being stored.

|   |   |   |
|---|---|---|
|Aspect|`CHAR`|`VARCHAR`|
|**Ideal Use Cases**|Best used when you know the strings will always be the same size (e.g., Pincode, country codes).|Best used when you have little idea about the size of the string to be entered (e.g., Name, address).|
|**Storage Utilization**|Utilizes the entire initialized storage by padding with trailing spaces.|Only uses the storage required for the actual data input, not the entire initialized length.|
|**Performance**|Generally gives better performance compared to `VARCHAR`.|Generally gives lower performance compared to `CHAR`.|
|**Handling Null Values**|SQL handles NULL values in `CHAR` columns inefficiently. Internally, a `CHAR` column intended to be `NULL` is often treated similarly to a `VARCHAR` to manage the absence of a value, negating some of the `CHAR` type's structural advantages in these specific cases.|A `VARCHAR` null column behaves as expected.|

To illustrate the storage difference, consider storing the string "Avi".

- In an attribute defined as `char(10)`, the database appends seven spaces to the string to make it exactly 10 characters long, consuming all 10 bytes of storage.
- In an attribute defined as `varchar(10)`, the database stores only the three characters "Avi" plus a small overhead to track the length, adding no extra spaces.

#### 2.3.4 Temporal Data Types

- `**DATE**`**:** Stores a date value with YEAR, MONTH, and DAY components. It is represented in a ten-position `YYYY-MM-DD` format.
- `**TIMESTAMP**`**:** Includes both `DATE` and `TIME` fields, along with a minimum of six positions for decimal fractions of seconds. It can be specified with an optional `WITH TIME ZONE` qualifier to handle time zone conversions.
- `**INTERVAL**`**:** Specifies a relative value that can be used to increment or decrement an absolute date, time, or timestamp value.

#### 2.3.5 Other Data Types

- **Bit-string data types:** Includes `BIT(n)` for fixed-length bit strings and `BIT VARYING(n)` for variable-length bit strings.
- **Boolean data type:** Holds one of two values: `TRUE` or `FALSE`.
- **Null Value:** The `NULL` value is not a data type itself but a special marker used to indicate an absent value. A null can signify that a value is unknown or that it does not exist at all for a particular record.

#### 2.3.6 Handling Large Objects (LOBs)

Modern applications often need to store data that is too large for standard data types, such as photos, medical images, video clips, or extensive documents. For these cases, SQL provides Large-Object (LOB) data types, which are designed to handle data on the order of many kilobytes, megabytes, or even gigabytes.

The two primary LOB types are:

- `**CLOB**` **(Character Large Object):** Used to store large amounts of character-based data. In MySQL, the `TEXT` data type family acts as the equivalent of `CLOB`.
- `**BLOB**` **(Binary Large Object):** Used to store large amounts of binary data, such as images, audio files, or videos.

Both `TEXT` and `BLOB` come in several sizes to accommodate different needs.

|   |   |   |
|---|---|---|
|Type|`TEXT(CLOB)` Max Size (Characters)|`BLOB` Max Size (Bytes)|
|**TINY**|255|255|
|**(regular)**|65,535|65,535 (~64 KB)|
|**MEDIUM**|16,777,215|16,777,215 (~16 MB)|
|**LONG**|4,294,967,295|4,294,967,295 (~4 GB)|

Key characteristics differ between `BLOB` and `TEXT` types:

- `**BLOB**` values are treated as binary strings. Sorting and comparison are based on the raw numeric byte values of the data. They cannot have a `DEFAULT` value.
- `**TEXT**` values are non-binary character strings that use a character set. Sorting and comparison follow the collation rules of that character set. Indexes on `TEXT` columns require a specified prefix length, and like `BLOB`s, they cannot have a `DEFAULT` value.

### 2.4 Enforcing Rules: Specifying Constraints

SQL constraints are rules and restrictions applied to the columns of a table to ensure the accuracy and reliability of the data. These constraints prevent invalid data from being entered into the database, thereby maintaining its overall integrity.

SQL directly supports the three basic constraint types of the Relational Model:

- **Key constraint:** A primary key value cannot be duplicated across rows in the same table.
- **Entity Integrity Constraint:** A primary key value cannot be null.
- **Referential integrity constraints:** A foreign key must have a value that is already present as a primary key in another table, or its value may be null.

SQL implements these theoretical constraints through specific clauses. The _key constraint_ and _entity integrity constraint_ are enforced together using the `PRIMARY KEY` clause, while _referential integrity_ is managed via the `FOREIGN KEY` clause.

Common SQL constraints are summarized below:

|   |   |
|---|---|
|Constraint|Description|
|`**NOT NULL**`|This constraint confirms that a column cannot store a `NULL` value.|
|`**UNIQUE**`|This constraint ensures that each row for a column must have a different value.|
|`**PRIMARY KEY**`|A combination of `NOT NULL` and `UNIQUE`. It ensures each row has a unique identifier, enforcing entity integrity.|
|`**CHECK**`|A `CHECK` constraint ensures that the value stored in a column meets a specific condition.|
|`**DEFAULT**`|This constraint provides a default value for a column when none is specified during data insertion.|
|`**FOREIGN KEY**`|A `FOREIGN KEY` constraint is used to ensure the referential integrity of the data. It requires that values in one table match values in another table.|

Constraints can be given a specific name using the `CONSTRAINT` keyword. This is a best practice, as it makes it much easier to modify or drop a specific constraint later using the `ALTER TABLE` command.

#### 2.4.1 Foreign Keys and Referential Actions

The `FOREIGN KEY` clause is fundamental to enforcing referential integrity between tables. It establishes a link where a column (or set of columns) in a "child" table refers to the primary key of a "parent" table. To manage what happens when a referenced parent record is changed, you can specify referential triggered actions using the `ON DELETE` and `ON UPDATE` clauses.

The available actions are:

- `**NO ACTION**`**:** (The default behavior) The database raises an error and rolls back the delete or update operation on the parent table if any corresponding rows exist in the child table.
- `**CASCADE**`**:** If a row in the parent table is deleted or updated, the corresponding rows in the child table are also automatically deleted or updated.
- `**SET NULL**`**:** When the referenced parent row is deleted or updated, the foreign key columns in the corresponding child table rows are set to `NULL`. This is only possible if the foreign key columns are nullable.
- `**SET DEFAULT**`**:** When the referenced parent row is deleted or updated, the foreign key columns in the corresponding child table rows are set to their defined default values. This requires the columns to have a default definition.

### 2.5 Modifying the Structure: The `ALTER` and `DROP` Commands

Database schemas are rarely static; they often need to evolve as application requirements change. `ALTER` and `DROP` are the primary DDL commands used to manage this "schema evolution," allowing for modifications to be made to the database structure while it is operational.

#### 2.5.1 The `ALTER TABLE` Command

The `ALTER TABLE` command is used to modify an existing table's structure in various ways. It is a powerful and flexible tool for database maintenance. Primary actions possible with `ALTER TABLE` include:

- **Add a column:** Adds a new column to the table. By default, it is added at the end, but `FIRST` or `AFTER` can specify its position.
- **Drop a column:** Permanently removes a column and its data.
- **Modify a column's definition:** Changes the data type or other properties of an existing column.
- **Rename a column:** The `CHANGE COLUMN` clause renames a column and can also change its definition simultaneously. The `RENAME COLUMN` clause (supported in some SQL dialects) only renames the column.
- **Change a column's** `**DEFAULT**` **value:** Sets or removes the default value for a column.
- **Add a constraint:** Adds a new constraint, such as a primary key, foreign key, or check constraint, to the table.
- **Drop a constraint:** Removes an existing constraint from the table.
- **Rename a table:** Changes the name of the table itself.

#### 2.5.2 The `DROP` and `TRUNCATE` Commands

The `DROP` command is used to permanently delete entire database objects, such as tables, views, or even entire schemas. When dropping an object, you can specify one of two behaviors:

- `**CASCADE**`**:** Removes the object and any other objects that are dependent on it (e.g., dropping a table will also drop its foreign key constraints in other tables).
- `**RESTRICT**`**:** Only drops the object if it is not referenced by any other database objects. This is a safer option that prevents accidental deletion of critical dependencies.

While both `DROP` and `TRUNCATE` can remove data, they function very differently and are used for distinct purposes.

|   |   |   |
|---|---|---|
|Feature|`DROP`|`TRUNCATE`|
|**What is removed**|Both data and the table structure.|Only the data (all rows). The table structure remains.|
|**Effect on** `**Auto_Increment**`|N/A (table is deleted)|Resets the counter to 1 (in MySQL).|
|**Constraints & Indexes**|Deleted along with the table.|Preserved with the table structure.|
|**Rollback Capability (MySQL)**|Cannot be rolled back.|Cannot be rolled back.|
|**Performance**|Slower, as it involves more system operations.|Faster, as it is a minimally logged operation.|
|**Memory Usage**|Frees all memory allocated to the table.|Does not necessarily free all allocated memory immediately.|
|**Primary Use Case**|When the table is no longer needed at all.|When you want to empty the table completely but keep its structure for future use.|

Having established how to define and manage the database structure with DDL, we can now turn our attention to working with the data inside that structure using DML.

## 3.0 Working with Data: Data Manipulation Language (DML)

Data Manipulation Language (DML) commands are the tools used to manage and query the data _within_ the database structures created by DDL. While DDL builds the house, DML populates it and manages its occupants. These commands cover the full lifecycle of data, from its initial insertion to its modification, deletion, and ultimate retrieval. The primary DML commands are `INSERT`, `UPDATE`, `DELETE`, and `SELECT`.

### 3.1 Adding Data: The `INSERT` Command

The `INSERT` command is used to add new rows (tuples) of data into a table. There are two primary forms for inserting a single tuple.

1. **Form 1 (Implicit Columns):** This form requires the values to be listed in the exact same order in which the columns were defined in the `CREATE TABLE` statement. All columns must be provided with a value.
    - **Syntax:** `INSERT INTO table_name VALUES (value1, value2, ...);`
    - **Example:** `INSERT INTO EMPLOYEE VALUES ('Richard', 'K', 'Marini', '653298653', '1962-12-30', '98 Oak Forest, Katy, TX', 'M', 37000, '653298653', 4);`
2. **Form 2 (Explicit Columns):** This form allows you to specify which columns are being populated. This is particularly useful when you don't have values for every column, or when you want to provide them in a different order. Any columns that are omitted must allow `NULL` values or have a `DEFAULT` value defined. Columns defined with `NOT NULL` and no default value must be included.
    - **Syntax:** `INSERT INTO table_name (column1, column2, ...) VALUES (value1, value2, ...);`
    - **Example:** `INSERT INTO EMPLOYEE (Fname, Lname, Dno, Ssn) VALUES ('Richard', 'Marini', 4, '653298653');`

A powerful variation of the `INSERT` command uses a `SELECT` statement to add multiple tuples to a table at once. This allows you to populate one table with data derived from one or more other tables.

- **Example:** Populate a new `WORKS_ON_INFO` table with data from `EMPLOYEE`, `PROJECT`, and `WORKS_ON`.

### 3.2 Modifying Data: The `UPDATE` Command

The `UPDATE` command is used to modify the attribute values of one or more existing tuples in a table. The command has two key clauses:

- The `**SET**` clause specifies which attributes to modify and their new values.
- The `**WHERE**` clause selects the specific tuple(s) to be modified. If the `WHERE` clause is omitted, all tuples in the table will be updated.

Here are two examples demonstrating its use:

1. **Simple Update:** Change the location and department number for a specific project.
2. **Calculated Update:** Give all employees in department number 5 a 10% raise.

**Note on MySQL Syntax:** MySQL does not allow you to update a table while selecting from the same table in a subquery within the `WHERE` clause. To work around this, the subquery must be wrapped in a derived table, as shown below.

### 3.3 Removing Data: The `DELETE` Command

The `DELETE` command removes one or more tuples from a table. It is crucial to use the `**WHERE**` clause to select the specific tuples you wish to delete.

**Warning:** If you execute a `DELETE` command without a `WHERE` clause, **all tuples in the table will be permanently deleted**. The table's structure will remain, but it will be empty.

- **Example:** Delete the employee record for an employee with the last name 'Zelaya'.

### 3.4 Retrieving Data: The `SELECT` Command

The `SELECT` command is the primary tool for querying a database and retrieving data. In its most basic form, the command consists of two main clauses:

- The `**SELECT**` clause lists the attributes (columns) you want to retrieve. This corresponds to the _projection_ operation in relational algebra.
- The `**FROM**` clause specifies the table from which to retrieve the data.
- **Example:** Retrieve the first and last names of all employees.

The `SELECT` statement is the most complex and powerful command in SQL and will be covered in greater detail in subsequent lessons.

## 4.0 Practical Case Study: The "COMPANY" Schema

To solidify the DDL and DML concepts discussed, this section presents the complete schema for a sample "COMPANY" database. This schema is used as the basis for many of the examples throughout this guide. The relationships between the tables are defined through primary and foreign keys.

The schema consists of the following six tables:

- `**EMPLOYEE**`
    - Columns: Fname, Minit, Lname, Ssn, Bdate, Address, Gender, Salary, Super_ssn, Dno
    - The `Ssn` column serves as the primary key. This table features two foreign keys: `Super_ssn` is a self-referencing foreign key to `Ssn`, establishing the supervision hierarchy within the company, and `Dno` is a foreign key to the `DEPARTMENT` table's `Dnumber` column, linking each employee to their assigned department.
- `**DEPARTMENT**`
    - Columns: Dname, Dnumber, Mgr_ssn, Mgr_start_date
    - The `Dnumber` column is the primary key for this table. The `Dname` column is defined as a candidate key with a `UNIQUE` constraint. The `Mgr_ssn` column is a foreign key that references the `Ssn` of an `EMPLOYEE`, identifying the department manager.
- `**DEPT_LOCATIONS**`
    - Columns: Dnumber, Dlocation
    - This table uses a composite primary key consisting of (`Dnumber`, `Dlocation`) to uniquely identify each location for a department. The `Dnumber` column is also a foreign key referencing the `DEPARTMENT` table's `Dnumber`, linking locations to their respective departments.
- `**PROJECT**`
    - Columns: Pname, Pnumber, Plocation, Dnum
    - The `Pnumber` column is the primary key. The `Dnum` column is a foreign key referencing the `DEPARTMENT` table's `Dnumber`, indicating which department controls the project.
- `**WORKS_ON**`
    - Columns: Essn, Pno, Hours
    - This is a junction table with a composite primary key of (`Essn`, `Pno`). It has two foreign keys: `Essn` references the `EMPLOYEE` table's `Ssn`, and `Pno` references the `PROJECT` table's `Pnumber`, creating a many-to-many relationship between employees and projects.
- `**DEPENDENT**`
    - Columns: Essn, Dependent_name, Gender, Bdate, Relationship
    - This table uses a composite primary key of (`Essn`, `Dependent_name`) to uniquely identify each dependent for a given employee. The `Essn` column is a foreign key that references the `EMPLOYEE` table's `Ssn`, linking dependents to the employee who supports them.

Below are the complete `CREATE TABLE` statements used to define this schema in a MySQL database.

```sql
CREATE TABLE `employee` (
  `Fname` varchar(15) NOT NULL,
  `Minit` char(1) DEFAULT NULL,
  `Lname` varchar(15) NOT NULL,
  `Ssn` char(9) NOT NULL,
  `Bdate` date DEFAULT NULL,
  `Address` varchar(30) DEFAULT NULL,
  `Gender` char(1) DEFAULT NULL,
  `Salary` decimal(10,2) DEFAULT NULL,
  `Super_ssn` char(9) DEFAULT NULL,
  `Dno` int(11) NOT NULL
);
```

```sql
CREATE TABLE `department` (
  `Dname` varchar(15) NOT NULL,
  `Dnumber` int(11) NOT NULL,
  `Mgr_ssn` char(9) NOT NULL,
  `Mgr_start_date` date DEFAULT NULL
);
```

```sql
CREATE TABLE `dept_locations` (
  `Dnumber` int(11) NOT NULL,
  `Dlocation` varchar(15) NOT NULL
);
```

```sql
CREATE TABLE `project` (
  `Pname` varchar(15) NOT NULL,
  `Pnumber` int(11) NOT NULL,
  `Plocation` varchar(15) DEFAULT NULL,
  `Dnum` int(11) NOT NULL
);
```

```sql
CREATE TABLE `works_on` (
  `Essn` char(9) NOT NULL,
  `Pno` int(11) NOT NULL,
  `Hours` decimal(3,1) DEFAULT NULL
);
```

```sql
CREATE TABLE `dependent` (
  `Essn` char(9) NOT NULL,
  `Dependent_name` varchar(15) NOT NULL,
  `Gender` char(1) DEFAULT NULL,
  `Bdate` date DEFAULT NULL,
  `Relationship` varchar(8) DEFAULT NULL
);
```

## 5.0 Knowledge Check

To test your understanding of the concepts covered in this guide, please review the following questions. The answers are provided at the end of this section.

**1. What is the difference between** `**CHAR(n)**` **and** `**VARCHAR(n)**`**?** A) `CHAR(n)` stores variable-length strings, `VARCHAR(n)` stores fixed-length strings B) `CHAR(n)` stores fixed-length strings, `VARCHAR(n)` stores variable-length strings C) Both store fixed-length strings D) Both store variable-length strings

**2. What is the format of the** `**DATE**` **data type in SQL?** A) DD-MM-YYYY B) MM-DD-YYYY C) YYYY-MM-DD D) Any format can be used

**3. What is a key difference between** `**BLOB**` **and** `**CLOB**` **data types?** A) `BLOB` is used for large binary objects, `CLOB` is used for large character data B) Both store large binary objects C) Both store large character objects D) `CLOB` is used for numbers only

**4. What is the purpose of the** `**ENUM**` **data type in MySQL?** A) Storing fixed-length character data B) Storing numeric data C) Defining a list of possible values for a column D) Storing date and time values

**5. Which command is used to delete all records from a table without removing its structure?** A) `DELETE` B) `DROP` C) `TRUNCATE` D) `ALTER`

**6. In SQL, what does the** `**DESCRIBE**` **command do?** A) Shows the details of a table structure B) Deletes a table C) Modifies a table D) Creates a new schema

**7. Which of the following statements is used to remove an entire table from the database?** A) `DELETE` B) `DROP` C) `TRUNCATE` D) `REMOVE`

**8. The** `**ALTER TABLE**` **statement is used to?** A) Remove a table B) Modify an existing table structure C) Retrieve table data D) Define a new schema

**9. Which SQL clause is used to specify the attributes that should be displayed in the output?** A) `FROM` B) `WHERE` C) `SELECT` D) `ORDER BY`

**10. Which DML operation is used to remove data from a database?** A) `SELECT` B) `INSERT` C) `DELETE` D) `UPDATE`

**11. In the SQL DML example,** `**"SELECT name FROM instructor WHERE dept_name = 'History'"**` **what does** `**'name'**` **refer to?** A) A column in the 'instructor' table B) A table in the database C) A value in the 'dept_name' column D) A query condition

**12. What is the purpose of the Data Manipulation Language (DML)?** A) Defining the structure of a database B) Querying the database C) Managing database access D) Storing the data in the database

--------------------------------------------------------------------------------

### Answers

1. B
2. C
3. A
4. C
5. C
6. A
7. B
8. B
9. C
10. C
11. A
12. B